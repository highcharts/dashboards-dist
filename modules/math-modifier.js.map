{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Dashboards Math 4.0.0-rc.1 (2025-10-27)\n * @module dashboards/modules/math-modifier\n * @requires dashboards\n *\n * (c) 2009-2025 Highsoft AS\n *\n * License: www.highcharts.com/license\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(root[\"_Dashboards\"], root[\"_Dashboards\"][\"DataModifier\"]);\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"dashboards/modules/math-modifier\", [\"dashboards/dashboards\"], function (amd1) {return factory(amd1,amd1[\"DataModifier\"]);});\n\telse if(typeof exports === 'object')\n\t\texports[\"dashboards/modules/math-modifier\"] = factory(root[\"_Dashboards\"], root[\"_Dashboards\"][\"DataModifier\"]);\n\telse\n\t\troot[\"Dashboards\"] = factory(root[\"Dashboards\"], root[\"Dashboards\"][\"DataModifier\"]);\n})(typeof window === 'undefined' ? this : window, (__WEBPACK_EXTERNAL_MODULE__668__, __WEBPACK_EXTERNAL_MODULE__784__) => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 668:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__668__;\n\n/***/ }),\n\n/***/ 784:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__784__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => (/* binding */ math_modifier_src)\n});\n\n// EXTERNAL MODULE: external {\"amd\":[\"dashboards/dashboards\"],\"commonjs\":[\"dashboards\"],\"commonjs2\":[\"dashboards\"],\"root\":[\"Dashboards\"]}\nvar dashboards_commonjs_dashboards_commonjs2_dashboards_root_Dashboards_ = __webpack_require__(668);\nvar dashboards_commonjs_dashboards_commonjs2_dashboards_root_Dashboards_default = /*#__PURE__*/__webpack_require__.n(dashboards_commonjs_dashboards_commonjs2_dashboards_root_Dashboards_);\n;// ./code/dashboards/es-modules/Data/Formula/FormulaParser.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { isString } = (dashboards_commonjs_dashboards_commonjs2_dashboards_root_Dashboards_default());\n/* *\n *\n *  Constants\n *\n * */\n/**\n * @private\n */\nconst booleanRegExp = /^(?:FALSE|TRUE)/;\n/**\n * `.`-separated decimal.\n * @private\n */\nconst decimal1RegExp = /^[+\\-]?\\d+(?:\\.\\d+)?(?:e[+\\-]\\d+)?/;\n/**\n * `,`-separated decimal.\n * @private\n */\nconst decimal2RegExp = /^[+\\-]?\\d+(?:,\\d+)?(?:e[+\\-]\\d+)?/;\n/**\n * - Group 1: Function name\n * @private\n */\nconst functionRegExp = /^([A-Z][A-Z\\d\\.]*)\\(/;\n/**\n * @private\n */\nconst operatorRegExp = /^(?:[+\\-*\\/^<=>]|<=|=>)/;\n/**\n * - Group 1: Start column\n * - Group 2: Start row\n * - Group 3: End column\n * - Group 4: End row\n * @private\n */\nconst rangeA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)\\:(\\$?[A-Z]+)(\\$?\\d+)/;\n/**\n * - Group 1: Start row\n * - Group 2: Start column\n * - Group 3: End row\n * - Group 4: End column\n * @private\n */\nconst rangeR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])\\:R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])/;\n/**\n * - Group 1: Column\n * - Group 2: Row\n * @private\n */\nconst referenceA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)(?![\\:C])/;\n/**\n * - Group 1: Row\n * - Group 2: Column\n * @private\n */\nconst referenceR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])(?!\\:)/;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Extracts the inner string of the most outer parantheses.\n *\n * @private\n *\n * @param {string} text\n * Text string to extract from.\n *\n * @return {string}\n * Extracted parantheses. If not found an exception will be thrown.\n */\nfunction extractParantheses(text) {\n    let parantheseLevel = 0;\n    for (let i = 0, iEnd = text.length, char, parantheseStart = 1; i < iEnd; ++i) {\n        char = text[i];\n        if (char === '(') {\n            if (!parantheseLevel) {\n                parantheseStart = i + 1;\n            }\n            ++parantheseLevel;\n            continue;\n        }\n        if (char === ')') {\n            --parantheseLevel;\n            if (!parantheseLevel) {\n                return text.substring(parantheseStart, i);\n            }\n        }\n    }\n    if (parantheseLevel > 0) {\n        const error = new Error('Incomplete parantheses.');\n        error.name = 'FormulaParseError';\n        throw error;\n    }\n    return '';\n}\n/**\n * Extracts the inner string value.\n *\n * @private\n *\n * @param {string} text\n * Text string to extract from.\n *\n * @return {string}\n * Extracted string. If not found an exception will be thrown.\n */\nfunction extractString(text) {\n    let start = -1;\n    for (let i = 0, iEnd = text.length, char, escaping = false; i < iEnd; ++i) {\n        char = text[i];\n        if (char === '\\\\') {\n            escaping = !escaping;\n            continue;\n        }\n        if (escaping) {\n            escaping = false;\n            continue;\n        }\n        if (char === '\"') {\n            if (start < 0) {\n                start = i;\n            }\n            else {\n                return text.substring(start + 1, i); // `Ã¬` is excluding\n            }\n        }\n    }\n    const error = new Error('Incomplete string.');\n    error.name = 'FormulaParseError';\n    throw error;\n}\n/**\n * Parses an argument string. Formula arrays with a single term will be\n * simplified to the term.\n *\n * @private\n *\n * @param {string} text\n * Argument string to parse.\n *\n * @param {boolean} alternativeSeparators\n * Whether to expect `;` as argument separator and `,` as decimal separator.\n *\n * @return {Formula|Function|Range|Reference|Value}\n * The recognized term structure.\n */\nfunction parseArgument(text, alternativeSeparators) {\n    let match;\n    // Check for a R1C1:R1C1 range notation\n    match = text.match(rangeR1C1RegExp);\n    if (match) {\n        const beginColumnRelative = (match[2] === '' || match[2][0] === '[');\n        const beginRowRelative = (match[1] === '' || match[1][0] === '[');\n        const endColumnRelative = (match[4] === '' || match[4][0] === '[');\n        const endRowRelative = (match[3] === '' || match[3][0] === '[');\n        const range = {\n            type: 'range',\n            beginColumn: (beginColumnRelative ?\n                parseInt(match[2].substring(1, -1) || '0', 10) :\n                parseInt(match[2], 10) - 1),\n            beginRow: (beginRowRelative ?\n                parseInt(match[1].substring(1, -1) || '0', 10) :\n                parseInt(match[1], 10) - 1),\n            endColumn: (endColumnRelative ?\n                parseInt(match[4].substring(1, -1) || '0', 10) :\n                parseInt(match[4], 10) - 1),\n            endRow: (endRowRelative ?\n                parseInt(match[3].substring(1, -1) || '0', 10) :\n                parseInt(match[3], 10) - 1)\n        };\n        if (beginColumnRelative) {\n            range.beginColumnRelative = true;\n        }\n        if (beginRowRelative) {\n            range.beginRowRelative = true;\n        }\n        if (endColumnRelative) {\n            range.endColumnRelative = true;\n        }\n        if (endRowRelative) {\n            range.endRowRelative = true;\n        }\n        return range;\n    }\n    // Check for a A1:A1 range notation\n    match = text.match(rangeA1RegExp);\n    if (match) {\n        const beginColumnRelative = match[1][0] !== '$';\n        const beginRowRelative = match[2][0] !== '$';\n        const endColumnRelative = match[3][0] !== '$';\n        const endRowRelative = match[4][0] !== '$';\n        const range = {\n            type: 'range',\n            beginColumn: parseReferenceColumn(beginColumnRelative ?\n                match[1] :\n                match[1].substring(1)) - 1,\n            beginRow: parseInt(beginRowRelative ?\n                match[2] :\n                match[2].substring(1), 10) - 1,\n            endColumn: parseReferenceColumn(endColumnRelative ?\n                match[3] :\n                match[3].substring(1)) - 1,\n            endRow: parseInt(endRowRelative ?\n                match[4] :\n                match[4].substring(1), 10) - 1\n        };\n        if (beginColumnRelative) {\n            range.beginColumnRelative = true;\n        }\n        if (beginRowRelative) {\n            range.beginRowRelative = true;\n        }\n        if (endColumnRelative) {\n            range.endColumnRelative = true;\n        }\n        if (endRowRelative) {\n            range.endRowRelative = true;\n        }\n        return range;\n    }\n    // Fallback to formula processing for other pattern types\n    const formula = parseFormula(text, alternativeSeparators);\n    return (formula.length === 1 && typeof formula[0] !== 'string' ?\n        formula[0] :\n        formula);\n}\n/**\n * Parse arguments string inside function parantheses.\n *\n * @private\n *\n * @param {string} text\n * Parantheses string of the function.\n *\n * @param {boolean} alternativeSeparators\n * Whether to expect `;` as argument separator and `,` as decimal separator.\n *\n * @return {Highcharts.FormulaArguments}\n * Parsed arguments array.\n */\nfunction parseArguments(text, alternativeSeparators) {\n    const args = [], argumentsSeparator = (alternativeSeparators ? ';' : ',');\n    let parantheseLevel = 0, term = '';\n    for (let i = 0, iEnd = text.length, char; i < iEnd; ++i) {\n        char = text[i];\n        // Check for separator\n        if (char === argumentsSeparator &&\n            !parantheseLevel &&\n            term) {\n            args.push(parseArgument(term, alternativeSeparators));\n            term = '';\n            // Check for a quoted string before skip logic\n        }\n        else if (char === '\"' &&\n            !parantheseLevel &&\n            !term) {\n            const string = extractString(text.substring(i));\n            args.push(string);\n            i += string.length + 1; // Only +1 to cover ++i in for-loop\n            // Skip space and check paranthesis nesting\n        }\n        else if (char !== ' ') {\n            term += char;\n            if (char === '(') {\n                ++parantheseLevel;\n            }\n            else if (char === ')') {\n                --parantheseLevel;\n            }\n        }\n    }\n    // Look for left-overs from last argument\n    if (!parantheseLevel && term) {\n        args.push(parseArgument(term, alternativeSeparators));\n    }\n    return args;\n}\n/**\n * Checks if there's one of the following operator before the negative number\n * value: '*', '/' or '^'.\n *\n * Used to properly indicate a negative value reference or negate a directly\n * passed number value.\n */\nfunction negativeReference(formula) {\n    const formulaLength = formula.length;\n    const priorFormula = formula[formulaLength - 2];\n    return (formula[formulaLength - 1] === '-' &&\n        isString(priorFormula) &&\n        !!priorFormula.match(/\\*|\\/|\\^/));\n}\n/**\n * Converts a spreadsheet formula string into a formula array. Throws a\n * `FormulaParserError` when the string can not be parsed.\n *\n * @private\n * @function Formula.parseFormula\n *\n * @param {string} text\n * Spreadsheet formula string, without the leading `=`.\n *\n * @param {boolean} alternativeSeparators\n * * `false` to expect `,` between arguments and `.` in decimals.\n * * `true` to expect `;` between arguments and `,` in decimals.\n *\n * @return {Formula.Formula}\n * Formula array representing the string.\n */\nfunction parseFormula(text, alternativeSeparators) {\n    const decimalRegExp = (alternativeSeparators ?\n        decimal2RegExp :\n        decimal1RegExp), formula = [];\n    let match, next = (text[0] === '=' ? text.substring(1) : text).trim();\n    while (next) {\n        // Check for an R1C1 reference notation\n        match = next.match(referenceR1C1RegExp);\n        if (match) {\n            const columnRelative = (match[2] === '' || match[2][0] === '[');\n            const rowRelative = (match[1] === '' || match[1][0] === '[');\n            const reference = {\n                type: 'reference',\n                column: (columnRelative ?\n                    parseInt(match[2].substring(1, -1) || '0', 10) :\n                    parseInt(match[2], 10) - 1),\n                row: (rowRelative ?\n                    parseInt(match[1].substring(1, -1) || '0', 10) :\n                    parseInt(match[1], 10) - 1)\n            };\n            if (columnRelative) {\n                reference.columnRelative = true;\n            }\n            if (rowRelative) {\n                reference.rowRelative = true;\n            }\n            if (negativeReference(formula)) {\n                formula.pop();\n                reference.isNegative = true;\n            }\n            formula.push(reference);\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for an A1 reference notation\n        match = next.match(referenceA1RegExp);\n        if (match) {\n            const columnRelative = match[1][0] !== '$';\n            const rowRelative = match[2][0] !== '$';\n            const reference = {\n                type: 'reference',\n                column: parseReferenceColumn(columnRelative ?\n                    match[1] :\n                    match[1].substring(1)) - 1,\n                row: parseInt(rowRelative ?\n                    match[2] :\n                    match[2].substring(1), 10) - 1\n            };\n            if (columnRelative) {\n                reference.columnRelative = true;\n            }\n            if (rowRelative) {\n                reference.rowRelative = true;\n            }\n            if (negativeReference(formula)) {\n                formula.pop();\n                reference.isNegative = true;\n            }\n            formula.push(reference);\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for a formula operator\n        match = next.match(operatorRegExp);\n        if (match) {\n            formula.push(match[0]);\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for a boolean value\n        match = next.match(booleanRegExp);\n        if (match) {\n            formula.push(match[0] === 'TRUE');\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for a number value\n        match = next.match(decimalRegExp);\n        if (match) {\n            let number = parseFloat(match[0]);\n            // If the current value is multiplication-related and the previous\n            // one is a minus sign, set the current value to negative and remove\n            // the minus sign.\n            if (negativeReference(formula)) {\n                formula.pop();\n                number = -number;\n            }\n            formula.push(number);\n            next = next.substring(match[0].length).trim();\n            continue;\n        }\n        // Check for a quoted string\n        if (next[0] === '\"') {\n            const string = extractString(next);\n            formula.push(string.substring(1, -1));\n            next = next.substring(string.length + 2).trim();\n            continue;\n        }\n        // Check for a function\n        match = next.match(functionRegExp);\n        if (match) {\n            next = next.substring(match[1].length).trim();\n            const parantheses = extractParantheses(next);\n            formula.push({\n                type: 'function',\n                name: match[1],\n                args: parseArguments(parantheses, alternativeSeparators)\n            });\n            next = next.substring(parantheses.length + 2).trim();\n            continue;\n        }\n        // Check for a formula in parantheses\n        if (next[0] === '(') {\n            const paranteses = extractParantheses(next);\n            if (paranteses) {\n                formula\n                    .push(parseFormula(paranteses, alternativeSeparators));\n                next = next.substring(paranteses.length + 2).trim();\n                continue;\n            }\n        }\n        // Something is not right\n        const position = text.length - next.length, error = new Error('Unexpected character `' +\n            text.substring(position, position + 1) +\n            '` at position ' + (position + 1) +\n            '. (`...' + text.substring(position - 5, position + 6) + '...`)');\n        error.name = 'FormulaParseError';\n        throw error;\n    }\n    return formula;\n}\n/**\n * Converts a reference column `A` of `A1` into a number. Supports endless sizes\n * `ZZZ...`, just limited by integer precision.\n *\n * @private\n *\n * @param {string} text\n * Column string to convert.\n *\n * @return {number}\n * Converted column index.\n */\nfunction parseReferenceColumn(text) {\n    let column = 0;\n    for (let i = 0, iEnd = text.length, code, factor = text.length - 1; i < iEnd; ++i) {\n        code = text.charCodeAt(i);\n        if (code >= 65 && code <= 90) {\n            column += (code - 64) * Math.pow(26, factor);\n        }\n        --factor;\n    }\n    return column;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst FormulaParser = {\n    parseFormula\n};\n/* harmony default export */ const Formula_FormulaParser = (FormulaParser);\n\n;// ./code/dashboards/es-modules/Data/Formula/FormulaTypes.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n/* *\n *\n *  Constants\n *\n * */\n/**\n * Array of all possible operators.\n * @private\n */\nconst operators = ['+', '-', '*', '/', '^', '=', '<', '<=', '>', '>='];\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Tests an item for a Formula array.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a formula (or argument) array.\n */\nfunction isFormula(item) {\n    return Array.isArray(item);\n}\n/**\n * Tests an item for a Function structure.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a formula function.\n */\nfunction isFunction(item) {\n    return (typeof item === 'object' &&\n        !(Array.isArray(item)) &&\n        item.type === 'function');\n}\n/**\n * Tests an item for an Operator string.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is an operator string.\n */\nfunction isOperator(item) {\n    return (typeof item === 'string' &&\n        operators.indexOf(item) >= 0);\n}\n/**\n * Tests an item for a Range structure.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a range.\n */\nfunction isRange(item) {\n    return (typeof item === 'object' &&\n        !(Array.isArray(item)) &&\n        item.type === 'range');\n}\n/**\n * Tests an item for a Reference structure.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a reference.\n */\nfunction isReference(item) {\n    return (typeof item === 'object' &&\n        !(Array.isArray(item)) &&\n        item.type === 'reference');\n}\n/**\n * Tests an item for a Value structure.\n *\n * @private\n *\n * @param {Highcharts.FormulaItem|null|undefined} item\n * Item to test.\n *\n * @return {boolean}\n * `true`, if the item is a value.\n */\nfunction isValue(item) {\n    return (typeof item === 'boolean' ||\n        typeof item === 'number' ||\n        typeof item === 'string');\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst MathFormula = {\n    isFormula,\n    isFunction,\n    isOperator,\n    isRange,\n    isReference,\n    isValue\n};\n/* harmony default export */ const FormulaTypes = (MathFormula);\n\n;// ./code/dashboards/es-modules/Data/Formula/FormulaProcessor.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { isFormula: FormulaProcessor_isFormula, isFunction: FormulaProcessor_isFunction, isOperator: FormulaProcessor_isOperator, isRange: FormulaProcessor_isRange, isReference: FormulaProcessor_isReference, isValue: FormulaProcessor_isValue } = FormulaTypes;\n\nconst { defined } = (dashboards_commonjs_dashboards_commonjs2_dashboards_root_Dashboards_default());\n/* *\n *\n *  Constants\n *\n * */\nconst asLogicalStringRegExp = / */;\nconst MAX_FALSE = Number.MAX_VALUE / 1.000000000001;\nconst MAX_STRING = Number.MAX_VALUE / 1.000000000002;\nconst MAX_TRUE = Number.MAX_VALUE;\nconst operatorPriority = {\n    '^': 3,\n    '*': 2,\n    '/': 2,\n    '+': 1,\n    '-': 1,\n    '=': 0,\n    '<': 0,\n    '<=': 0,\n    '>': 0,\n    '>=': 0\n};\nconst processorFunctions = {};\nconst processorFunctionNameRegExp = /^[A-Z][A-Z\\.]*$/;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Converts non-number types to logical numbers.\n *\n * @param {Highcharts.FormulaValue} value\n * Value to convert.\n *\n * @return {number}\n * Logical number value. `NaN` if not convertable.\n */\nfunction asLogicalNumber(value) {\n    switch (typeof value) {\n        case 'boolean':\n            return value ? MAX_TRUE : MAX_FALSE;\n        case 'string':\n            return MAX_STRING;\n        case 'number':\n            return value;\n        default:\n            return NaN;\n    }\n}\n/**\n * Converts strings to logical strings, while other types get passed through. In\n * logical strings the space character is the lowest value and letters are case\n * insensitive.\n *\n * @param {Highcharts.FormulaValue} value\n * Value to convert.\n *\n * @return {Highcharts.FormulaValue}\n * Logical string value or passed through value.\n */\nfunction asLogicalString(value) {\n    if (typeof value === 'string') {\n        return value.toLowerCase().replace(asLogicalStringRegExp, '\\0');\n    }\n    return value;\n}\n/**\n * Converts non-number types to a logic number.\n *\n * @param {Highcharts.FormulaValue} value\n * Value to convert.\n *\n * @return {number}\n * Number value. `NaN` if not convertable.\n */\nfunction asNumber(value) {\n    switch (typeof value) {\n        case 'boolean':\n            return value ? 1 : 0;\n        case 'string':\n            return parseFloat(value.replace(',', '.'));\n        case 'number':\n            return value;\n        default:\n            return NaN;\n    }\n}\n/**\n * Process a basic operation of two given values.\n *\n * @private\n *\n * @param {Highcharts.FormulaOperator} operator\n * Operator between values.\n *\n * @param {Highcharts.FormulaValue} x\n * First value for operation.\n *\n * @param {Highcharts.FormulaValue} y\n * Second value for operation.\n *\n * @return {Highcharts.FormulaValue}\n * Operation result. `NaN` if operation is not support.\n */\nfunction basicOperation(operator, x, y) {\n    switch (operator) {\n        case '=':\n            return asLogicalString(x) === asLogicalString(y);\n        case '<':\n            if (typeof x === typeof y) {\n                return asLogicalString(x) < asLogicalString(y);\n            }\n            return asLogicalNumber(x) < asLogicalNumber(y);\n        case '<=':\n            if (typeof x === typeof y) {\n                return asLogicalString(x) <= asLogicalString(y);\n            }\n            return asLogicalNumber(x) <= asLogicalNumber(y);\n        case '>':\n            if (typeof x === typeof y) {\n                return asLogicalString(x) > asLogicalString(y);\n            }\n            return asLogicalNumber(x) > asLogicalNumber(y);\n        case '>=':\n            if (typeof x === typeof y) {\n                return asLogicalString(x) >= asLogicalString(y);\n            }\n            return asLogicalNumber(x) >= asLogicalNumber(y);\n    }\n    x = asNumber(x);\n    y = asNumber(y);\n    let result;\n    switch (operator) {\n        case '+':\n            result = x + y;\n            break;\n        case '-':\n            result = x - y;\n            break;\n        case '*':\n            result = x * y;\n            break;\n        case '/':\n            result = x / y;\n            break;\n        case '^':\n            result = Math.pow(x, y);\n            break;\n        default:\n            return NaN;\n    }\n    // Limit decimal to 9 digits\n    return (result % 1 ?\n        Math.round(result * 1000000000) / 1000000000 :\n        result);\n}\n/**\n * Converts an argument to Value and in case of a range to an array of Values.\n *\n * @function Highcharts.Formula.getArgumentValue\n *\n * @param {Highcharts.FormulaRange|Highcharts.FormulaTerm} arg\n * Formula range or term to convert.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n * Converted value.\n */\nfunction getArgumentValue(arg, table) {\n    // Add value\n    if (FormulaProcessor_isValue(arg)) {\n        return arg;\n    }\n    // Add values of a range\n    if (FormulaProcessor_isRange(arg)) {\n        return (table && getRangeValues(arg, table) || []);\n    }\n    // Add values of a function\n    if (FormulaProcessor_isFunction(arg)) {\n        return processFunction(arg, table);\n    }\n    // Process functions, operations, references with formula processor\n    return processFormula((FormulaProcessor_isFormula(arg) ? arg : [arg]), table);\n}\n/**\n * Converts all arguments to Values and in case of ranges to arrays of Values.\n *\n * @function Highcharts.Formula.getArgumentsValues\n *\n * @param {Highcharts.FormulaArguments} args\n * Formula arguments to convert.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Array<(Highcharts.FormulaValue|Array<Highcharts.FormulaValue>)>}\n * Converted values.\n */\nfunction getArgumentsValues(args, table) {\n    const values = [];\n    for (let i = 0, iEnd = args.length; i < iEnd; ++i) {\n        values.push(getArgumentValue(args[i], table));\n    }\n    return values;\n}\n/**\n * Extracts cell values from a table for a given range.\n *\n * @function Highcharts.Formula.getRangeValues\n *\n * @param {Highcharts.FormulaRange} range\n * Formula range to use.\n *\n * @param {Highcharts.DataTable} table\n * Table to extract from.\n *\n * @return {Array<Highcharts.FormulaValue>}\n * Extracted values.\n */\nfunction getRangeValues(range, table) {\n    const columnIds = table\n        .getColumnIds()\n        .slice(range.beginColumn, range.endColumn + 1), values = [];\n    for (let i = 0, iEnd = columnIds.length, cell; i < iEnd; ++i) {\n        const cells = table.getColumn(columnIds[i], true) || [];\n        for (let j = range.beginRow, jEnd = range.endRow + 1; j < jEnd; ++j) {\n            cell = cells[j];\n            if (typeof cell === 'string' &&\n                cell[0] === '=' &&\n                table !== table.getModified()) {\n                // Look in the modified table for formula result\n                cell = table.getModified().getCell(columnIds[i], j);\n            }\n            values.push(FormulaProcessor_isValue(cell) ? cell : NaN);\n        }\n    }\n    return values;\n}\n/**\n * Extracts the cell value from a table for a given reference.\n *\n * @private\n *\n * @param {Highcharts.FormulaReference} reference\n * Formula reference to use.\n *\n * @param {Highcharts.DataTable} table\n * Table to extract from.\n *\n * @return {Highcharts.FormulaValue}\n * Extracted value. 'undefined' might also indicate that the cell was not found.\n */\nfunction getReferenceValue(reference, table) {\n    const columnId = table.getColumnIds()[reference.column];\n    if (columnId) {\n        const cell = table.getCell(columnId, reference.row);\n        if (typeof cell === 'string' &&\n            cell[0] === '=' &&\n            table !== table.getModified()) {\n            // Look in the modified table for formula result\n            const result = table.getModified().getCell(columnId, reference.row);\n            return FormulaProcessor_isValue(result) ? result : NaN;\n        }\n        if (FormulaProcessor_isValue(cell)) {\n            return reference.isNegative ? -cell : cell;\n        }\n        return NaN;\n    }\n    return NaN;\n}\n/**\n * Calculates a value based on the two top values and the related operator.\n *\n * Used to properly process the formula's values based on its operators.\n *\n * @private\n * @function Highcharts.applyOperator\n *\n * @param {Array<Highcharts.Value>} values\n * Processed formula values.\n *\n * @param {Array<Highcharts.Operator>} operators\n * Processed formula operators.\n */\nfunction applyOperator(values, operators) {\n    if (values.length < 2 || operators.length < 1) {\n        values.push(NaN);\n    }\n    const secondValue = values.pop();\n    const firstValue = values.pop();\n    const operator = operators.pop();\n    if (!defined(secondValue) || !defined(firstValue) || !defined(operator)) {\n        values.push(NaN);\n    }\n    else {\n        values.push(basicOperation(operator, firstValue, secondValue));\n    }\n}\n/**\n * Processes a formula array on the given table. If the formula does not contain\n * references or ranges, then no table has to be provided.\n *\n * Performs formulas considering the operators precedence.\n *\n * // Example of the `2 * 3 + 4` formula:\n * 2 -> values: [2], operators: []\n * * -> values: [2], operators: [*]\n * 3 -> values: [2, 3], operators: [*]\n * // Since the higher precedence operator exists (* > +), perform it first.\n * + -> values: [6], operators: [+]\n * 4 -> values: [6, 4], operators: [+]\n * // When non-higher precedence operators remain, perform rest calculations.\n * -> values: [10], operators: []\n *\n * @private\n * @function Highcharts.processFormula\n *\n * @param {Highcharts.Formula} formula\n * Formula array to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Highcharts.FormulaValue}\n * Result value of the process. `NaN` indicates an error.\n */\nfunction processFormula(formula, table) {\n    // Keeps all the values to calculate them in a proper priority, based on the\n    // given operators.\n    const values = [];\n    // Keeps all the operators to calculate the values above, following the\n    // proper priority.\n    const operators = [];\n    // Indicates if the next item is a value (not an operator).\n    let expectingValue = true;\n    for (let i = 0, iEnd = formula.length; i < iEnd; ++i) {\n        const item = formula[i];\n        if (FormulaProcessor_isOperator(item)) {\n            if (expectingValue && item === '-') {\n                // Split the negative values to be handled as a binary\n                // operation if the next item is a value.\n                values.push(0);\n                operators.push('-');\n                expectingValue = true;\n            }\n            else {\n                // Perform if the higher precedence operator exist.\n                while (operators.length &&\n                    operatorPriority[operators[operators.length - 1]] >=\n                        operatorPriority[item]) {\n                    applyOperator(values, operators);\n                }\n                operators.push(item);\n                expectingValue = true;\n            }\n            continue;\n        }\n        let value;\n        // Assign the proper value, starting from the most common types.\n        if (FormulaProcessor_isValue(item)) {\n            value = item;\n        }\n        else if (FormulaProcessor_isReference(item)) {\n            value = table ? getReferenceValue(item, table) : NaN;\n        }\n        else if (FormulaProcessor_isFunction(item)) {\n            const result = processFunction(item, table);\n            value = FormulaProcessor_isValue(result) ? result : NaN;\n        }\n        else if (FormulaProcessor_isFormula(item)) {\n            value = processFormula(item, table);\n        }\n        if (typeof value !== 'undefined') {\n            values.push(value);\n            expectingValue = false;\n        }\n        else {\n            return NaN;\n        }\n    }\n    // Handle the remaining operators that weren't taken into consideration, due\n    // to non-higher precedence.\n    while (operators.length) {\n        applyOperator(values, operators);\n    }\n    if (values.length !== 1) {\n        return NaN;\n    }\n    return values[0];\n}\n/**\n * Process a function on the given table. If the arguments do not contain\n * references or ranges, then no table has to be provided.\n *\n * @private\n *\n * @param {Highcharts.FormulaFunction} formulaFunction\n * Formula function to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @param {Highcharts.FormulaReference} [reference]\n * Table cell reference to use for relative references and ranges.\n *\n * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n * Result value (or values) of the process. `NaN` indicates an error.\n */\nfunction processFunction(formulaFunction, table, \n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nreference // @todo\n) {\n    const processor = processorFunctions[formulaFunction.name];\n    if (processor) {\n        try {\n            return processor(formulaFunction.args, table);\n        }\n        catch {\n            return NaN;\n        }\n    }\n    const error = new Error(`Function \"${formulaFunction.name}\" not found.`);\n    error.name = 'FormulaProcessError';\n    throw error;\n}\n/**\n * Registers a function for the FormulaProcessor.\n *\n * @param {string} name\n * Name of the function in spreadsheets notation with upper case.\n *\n * @param {Highcharts.FormulaFunction} processorFunction\n * ProcessorFunction for the FormulaProcessor. This is an object so that it\n * can take additional parameter for future validation routines.\n *\n * @return {boolean}\n * Return true, if the ProcessorFunction has been registered.\n */\nfunction registerProcessorFunction(name, processorFunction) {\n    return (processorFunctionNameRegExp.test(name) &&\n        !processorFunctions[name] &&\n        !!(processorFunctions[name] = processorFunction));\n}\n/**\n * Translates relative references and ranges in-place.\n *\n * @param {Highcharts.Formula} formula\n * Formula to translate references and ranges in.\n *\n * @param {number} [columnDelta=0]\n * Column delta to translate to. Negative translate back.\n *\n * @param {number} [rowDelta=0]\n * Row delta to translate to. Negative numbers translate back.\n *\n * @return {Highcharts.Formula}\n * Formula with translated reference and ranges. This formula is equal to the\n * first argument.\n */\nfunction translateReferences(formula, columnDelta = 0, rowDelta = 0) {\n    for (let i = 0, iEnd = formula.length, item; i < iEnd; ++i) {\n        item = formula[i];\n        if (Array.isArray(item)) {\n            translateReferences(item, columnDelta, rowDelta);\n        }\n        else if (FormulaProcessor_isFunction(item)) {\n            translateReferences(item.args, columnDelta, rowDelta);\n        }\n        else if (FormulaProcessor_isRange(item)) {\n            if (item.beginColumnRelative) {\n                item.beginColumn += columnDelta;\n            }\n            if (item.beginRowRelative) {\n                item.beginRow += rowDelta;\n            }\n            if (item.endColumnRelative) {\n                item.endColumn += columnDelta;\n            }\n            if (item.endRowRelative) {\n                item.endRow += rowDelta;\n            }\n        }\n        else if (FormulaProcessor_isReference(item)) {\n            if (item.columnRelative) {\n                item.column += columnDelta;\n            }\n            if (item.rowRelative) {\n                item.row += rowDelta;\n            }\n        }\n    }\n    return formula;\n}\n/* *\n *\n *  Default Export\n *\n * */\nconst FormulaProcessor = {\n    asNumber,\n    getArgumentValue,\n    getArgumentsValues,\n    getRangeValues,\n    getReferenceValue,\n    processFormula,\n    processorFunctions,\n    registerProcessorFunction,\n    translateReferences\n};\n/* harmony default export */ const Formula_FormulaProcessor = (FormulaProcessor);\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/ABS.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: ABS_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `ABS(value)` implementation. Returns positive numbers.\n *\n * @private\n * @function Formula.processorFunctions.AND\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Array<number>}\n * Result value of the process.\n */\nfunction ABS(args, table) {\n    const value = ABS_getArgumentValue(args[0], table);\n    switch (typeof value) {\n        case 'number':\n            return Math.abs(value);\n        case 'object': {\n            const values = [];\n            for (let i = 0, iEnd = value.length, value2; i < iEnd; ++i) {\n                value2 = value[i];\n                if (typeof value2 !== 'number') {\n                    return NaN;\n                }\n                values.push(Math.abs(value2));\n            }\n            return values;\n        }\n        default:\n            return NaN;\n    }\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('ABS', ABS);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_ABS = ((/* unused pure expression or super */ null && (ABS)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/AND.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: AND_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `AND(...tests)` implementation. Returns `TRUE`, if all test\n * results are not `0` or `FALSE`.\n *\n * @private\n * @function Formula.processorFunctions.AND\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean}\n * Result value of the process.\n */\nfunction AND(args, table) {\n    for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n        value = AND_getArgumentValue(args[i], table);\n        if (!value ||\n            (typeof value === 'object' &&\n                !AND(value, table))) {\n            return false;\n        }\n    }\n    return true;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('AND', AND);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_AND = ((/* unused pure expression or super */ null && (AND)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/AVERAGE.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentsValues: AVERAGE_getArgumentsValues } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `AVERAGE(...values)` implementation. Calculates the average\n * of the given values that are numbers.\n *\n * @private\n * @function Formula.processorFunctions.AVERAGE\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction AVERAGE(args, table) {\n    const values = AVERAGE_getArgumentsValues(args, table);\n    let count = 0, result = 0;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    ++count;\n                    result += value;\n                }\n                break;\n            case 'object':\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    if (typeof value2 === 'number' &&\n                        !isNaN(value2)) {\n                        ++count;\n                        result += value2;\n                    }\n                }\n                break;\n        }\n    }\n    return (count ? (result / count) : 0);\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('AVERAGE', AVERAGE);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_AVERAGE = ((/* unused pure expression or super */ null && (AVERAGE)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/AVERAGEA.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: AVERAGEA_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `AVERAGEA(...values)` implementation. Calculates the\n * average of the given values. Strings and FALSE are calculated as 0.\n *\n * @private\n * @function Formula.processorFunctions.AVERAGEA\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction AVERAGEA(args, table) {\n    let count = 0, result = 0;\n    for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n        value = AVERAGEA_getArgumentValue(args[i], table);\n        switch (typeof value) {\n            case 'boolean':\n                ++count;\n                result += (value ? 1 : 0);\n                continue;\n            case 'number':\n                if (!isNaN(value)) {\n                    ++count;\n                    result += value;\n                }\n                continue;\n            case 'string':\n                ++count;\n                continue;\n            default:\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    switch (typeof value2) {\n                        case 'boolean':\n                            ++count;\n                            result += (value2 ? 1 : 0);\n                            continue;\n                        case 'number':\n                            if (!isNaN(value2)) {\n                                ++count;\n                                result += value2;\n                            }\n                            continue;\n                        case 'string':\n                            ++count;\n                            continue;\n                    }\n                }\n                continue;\n        }\n    }\n    return (count ? (result / count) : 0);\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('AVERAGEA', AVERAGEA);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_AVERAGEA = ((/* unused pure expression or super */ null && (AVERAGEA)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/COUNT.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `COUNT(...values)` implementation. Returns the count of\n * given values that are numbers.\n *\n * @private\n * @function Formula.processorFunctions.COUNT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction COUNT(args, table) {\n    const values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    let count = 0;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    ++count;\n                }\n                break;\n            case 'object':\n                count += COUNT(value, table);\n                break;\n        }\n    }\n    return count;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('COUNT', COUNT);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_COUNT = ((/* unused pure expression or super */ null && (COUNT)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/COUNTA.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `COUNTA(...values)` implementation. Returns the count of\n * given values that are not empty.\n *\n * @private\n * @function Formula.processorFunctions.COUNT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction COUNTA(args, table) {\n    const values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    let count = 0;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (isNaN(value)) {\n                    continue;\n                }\n                break;\n            case 'object':\n                count += COUNTA(value, table);\n                continue;\n            case 'string':\n                if (!value) {\n                    continue;\n                }\n                break;\n        }\n        ++count;\n    }\n    return count;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('COUNTA', COUNTA);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_COUNTA = ((/* unused pure expression or super */ null && (COUNTA)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/IF.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: IF_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `IF(test, value1, value2)` implementation. Returns one of\n * the values based on the test result. `value1` will be returned, if the test\n * result is not `0` or `FALSE`.\n *\n * @private\n * @function Formula.processorFunctions.IF\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n * Result value of the process.\n */\nfunction IF(args, table) {\n    return (IF_getArgumentValue(args[0], table) ?\n        IF_getArgumentValue(args[1], table) :\n        IF_getArgumentValue(args[2], table));\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('IF', IF);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_IF = ((/* unused pure expression or super */ null && (IF)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/ISNA.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: ISNA_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `ISNA(value)` implementation. Returns TRUE if value is not\n * a number.\n *\n * @private\n * @function Formula.processorFunctions.ISNA\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean}\n * Result value of the process.\n */\nfunction ISNA(args, table) {\n    const value = ISNA_getArgumentValue(args[0], table);\n    return (typeof value !== 'number' || isNaN(value));\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('ISNA', ISNA);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_ISNA = ((/* unused pure expression or super */ null && (ISNA)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/MAX.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentsValues: MAX_getArgumentsValues } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `MAX(...values)` implementation. Calculates the largest\n * of the given values that are numbers.\n *\n * @private\n * @function Formula.processorFunctions.MAX\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction MAX(args, table) {\n    const values = MAX_getArgumentsValues(args, table);\n    let result = Number.NEGATIVE_INFINITY;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (value > result) {\n                    result = value;\n                }\n                break;\n            case 'object':\n                value = MAX(value);\n                if (value > result) {\n                    result = value;\n                }\n                break;\n        }\n    }\n    return isFinite(result) ? result : 0;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MAX', MAX);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_MAX = ((/* unused pure expression or super */ null && (MAX)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/MEDIAN.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `MEDIAN(...values)` implementation. Calculates the median\n * average of the given values.\n *\n * @private\n * @function Formula.processorFunctions.MEDIAN\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction MEDIAN(args, table) {\n    const median = [], values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    median.push(value);\n                }\n                break;\n            case 'object':\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    if (typeof value2 === 'number' &&\n                        !isNaN(value2)) {\n                        median.push(value2);\n                    }\n                }\n                break;\n        }\n    }\n    const count = median.length;\n    if (!count) {\n        return NaN;\n    }\n    const half = Math.floor(count / 2); // Floor because index starts at 0\n    return (count % 2 ?\n        median[half] : // Odd\n        (median[half - 1] + median[half]) / 2 // Even\n    );\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MEDIAN', MEDIAN);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_MEDIAN = ((/* unused pure expression or super */ null && (MEDIAN)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/MIN.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentsValues: MIN_getArgumentsValues } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `MIN(...values)` implementation. Calculates the lowest\n * of the given values that are numbers.\n *\n * @private\n * @function Formula.processorFunctions.MIN\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction MIN(args, table) {\n    const values = MIN_getArgumentsValues(args, table);\n    let result = Number.POSITIVE_INFINITY;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (value < result) {\n                    result = value;\n                }\n                break;\n            case 'object':\n                value = MIN(value);\n                if (value < result) {\n                    result = value;\n                }\n                break;\n        }\n    }\n    return isFinite(result) ? result : 0;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MIN', MIN);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_MIN = ((/* unused pure expression or super */ null && (MIN)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/MOD.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: MOD_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `MOD(value1, value2)` implementation. Calculates the rest\n * of the division with the given values.\n *\n * @private\n * @function Formula.processorFunctions.MOD\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction MOD(args, table) {\n    let value1 = MOD_getArgumentValue(args[0], table), value2 = MOD_getArgumentValue(args[1], table);\n    if (typeof value1 === 'object') {\n        value1 = value1[0];\n    }\n    if (typeof value2 === 'object') {\n        value2 = value2[0];\n    }\n    if (typeof value1 !== 'number' ||\n        typeof value2 !== 'number' ||\n        value2 === 0) {\n        return NaN;\n    }\n    return value1 % value2;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MOD', MOD);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_MOD = ((/* unused pure expression or super */ null && (MOD)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/MODE.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Creates the mode map of the given arguments.\n *\n * @private\n * @function Formula.processorFunctions.MULT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction getModeMap(args, table) {\n    const modeMap = {}, values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    modeMap[value] = (modeMap[value] || 0) + 1;\n                }\n                break;\n            case 'object':\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    if (typeof value2 === 'number' &&\n                        !isNaN(value2)) {\n                        modeMap[value2] = (modeMap[value2] || 0) + 1;\n                    }\n                }\n                break;\n        }\n    }\n    return modeMap;\n}\n/**\n * Processor for the `MODE.MULT(...values)` implementation. Calculates the most\n * frequent values of the give values.\n *\n * @private\n * @function Formula.processorFunctions.MULT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number|Array<number>}\n * Result value of the process.\n */\nfunction MULT(args, table) {\n    const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n    if (!keys.length) {\n        return NaN;\n    }\n    let modeKeys = [parseFloat(keys[0])], modeCount = modeMap[keys[0]];\n    for (let i = 1, iEnd = keys.length, key, count; i < iEnd; ++i) {\n        key = keys[i];\n        count = modeMap[key];\n        if (modeCount < count) {\n            modeKeys = [parseFloat(key)];\n            modeCount = count;\n        }\n        else if (modeCount === count) {\n            modeKeys.push(parseFloat(key));\n        }\n    }\n    return modeCount > 1 ? modeKeys : NaN;\n}\n/**\n * Processor for the `MODE.SNGL(...values)` implementation. Calculates the\n * lowest most frequent value of the give values.\n *\n * @private\n * @function Formula.processorFunctions['MODE.SNGL']\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction SNGL(args, table) {\n    const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n    if (!keys.length) {\n        return NaN;\n    }\n    let modeKey = parseFloat(keys[0]), modeCount = modeMap[keys[0]];\n    for (let i = 1, iEnd = keys.length, key, keyValue, count; i < iEnd; ++i) {\n        key = keys[i];\n        count = modeMap[key];\n        if (modeCount < count) {\n            modeKey = parseFloat(key);\n            modeCount = count;\n        }\n        else if (modeCount === count) {\n            keyValue = parseFloat(key);\n            if (modeKey > keyValue) {\n                modeKey = keyValue;\n                modeCount = count;\n            }\n        }\n    }\n    return modeCount > 1 ? modeKey : NaN;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('MODE', SNGL);\nFormula_FormulaProcessor.registerProcessorFunction('MODE.MULT', MULT);\nFormula_FormulaProcessor.registerProcessorFunction('MODE.SNGL', SNGL);\n/* *\n *\n *  Default Export\n *\n * */\nconst MODE = {\n    MULT,\n    SNGL\n};\n/* harmony default export */ const Functions_MODE = ((/* unused pure expression or super */ null && (MODE)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/NOT.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: NOT_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `NOT(value)` implementation. Returns the opposite test\n * result.\n *\n * @private\n * @function Formula.processorFunctions.NOT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean|number}\n * Result value of the process.\n */\nfunction NOT(args, table) {\n    let value = NOT_getArgumentValue(args[0], table);\n    if (typeof value === 'object') {\n        value = value[0];\n    }\n    switch (typeof value) {\n        case 'boolean':\n        case 'number':\n            return !value;\n    }\n    return NaN;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('NOT', NOT);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_NOT = ((/* unused pure expression or super */ null && (NOT)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/OR.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: OR_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `OR(...tests)` implementation. Returns `TRUE`, if one test\n * result is not `0` or `FALSE`.\n *\n * @private\n * @function Formula.processorFunctions.AND\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean}\n * Result value of the process.\n */\nfunction OR(args, table) {\n    for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n        value = OR_getArgumentValue(args[i], table);\n        if (typeof value === 'object') {\n            if (OR(value, table)) {\n                return true;\n            }\n        }\n        else if (value) {\n            return true;\n        }\n    }\n    return false;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('OR', OR);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_OR = ((/* unused pure expression or super */ null && (OR)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/PRODUCT.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentsValues: PRODUCT_getArgumentsValues } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `PRODUCT(...values)` implementation. Calculates the product\n * of the given values.\n *\n * @private\n * @function Formula.processorFunctions.PRODUCT\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction PRODUCT(args, table) {\n    const values = PRODUCT_getArgumentsValues(args, table);\n    let result = 1, calculated = false;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    calculated = true;\n                    result *= value;\n                }\n                break;\n            case 'object':\n                calculated = true;\n                result *= PRODUCT(value, table);\n                break;\n        }\n    }\n    return (calculated ? result : 0);\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('PRODUCT', PRODUCT);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_PRODUCT = ((/* unused pure expression or super */ null && (PRODUCT)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/SUM.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `SUM(...values)` implementation. Calculates the sum of the\n * given values.\n *\n * @private\n * @function Formula.processorFunctions.SUM\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to process.\n *\n * @return {number}\n * Result value of the process.\n */\nfunction SUM(args, table) {\n    const values = Formula_FormulaProcessor.getArgumentsValues(args, table);\n    let result = 0;\n    for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n        value = values[i];\n        switch (typeof value) {\n            case 'number':\n                if (!isNaN(value)) {\n                    result += value;\n                }\n                break;\n            case 'object':\n                result += SUM(value, table);\n                break;\n        }\n    }\n    return result;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('SUM', SUM); // ð\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_SUM = ((/* unused pure expression or super */ null && (SUM)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Functions/XOR.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\nconst { getArgumentValue: XOR_getArgumentValue } = Formula_FormulaProcessor;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Processor for the `XOR(...tests)` implementation. Returns `TRUE`, if at least\n * one of the given tests differs in result of other tests.\n *\n * @private\n * @function Formula.processorFunctions.AND\n *\n * @param {Highcharts.FormulaArguments} args\n * Arguments to process.\n *\n * @param {Highcharts.DataTable} [table]\n * Table to use for references and ranges.\n *\n * @return {boolean|number}\n * Result value of the process.\n */\nfunction XOR(args, table) {\n    for (let i = 0, iEnd = args.length, lastValue, value; i < iEnd; ++i) {\n        value = XOR_getArgumentValue(args[i], table);\n        switch (typeof value) {\n            case 'boolean':\n            case 'number':\n                if (typeof lastValue === 'undefined') {\n                    lastValue = !!value;\n                }\n                else if (!!value !== lastValue) {\n                    return true;\n                }\n                break;\n            case 'object':\n                for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                    value2 = value[j];\n                    switch (typeof value2) {\n                        case 'boolean':\n                        case 'number':\n                            if (typeof lastValue === 'undefined') {\n                                lastValue = !!value2;\n                            }\n                            else if (!!value2 !== lastValue) {\n                                return true;\n                            }\n                            break;\n                    }\n                }\n                break;\n        }\n    }\n    return false;\n}\n/* *\n *\n *  Registry\n *\n * */\nFormula_FormulaProcessor.registerProcessorFunction('XOR', XOR);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Functions_XOR = ((/* unused pure expression or super */ null && (XOR)));\n\n;// ./code/dashboards/es-modules/Data/Formula/Formula.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n/* *\n *\n *  Imports\n *\n * */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* *\n *\n *  Default Export\n *\n * */\n/**\n * Formula engine to make use of spreadsheet formula strings.\n * @internal\n */\nconst Formula = {\n    ...Formula_FormulaParser,\n    ...Formula_FormulaProcessor,\n    ...FormulaTypes\n};\n/* harmony default export */ const Formula_Formula = (Formula);\n\n// EXTERNAL MODULE: external {\"amd\":[\"dashboards/dashboards\",\"DataModifier\"],\"commonjs\":[\"dashboards\",\"DataModifier\"],\"commonjs2\":[\"dashboards\",\"DataModifier\"],\"root\":[\"Dashboards\",\"DataModifier\"]}\nvar dashboards_DataModifier_commonjs_dashboards_DataModifier_commonjs2_dashboards_DataModifier_root_Dashboards_DataModifier_ = __webpack_require__(784);\nvar dashboards_DataModifier_commonjs_dashboards_DataModifier_commonjs2_dashboards_DataModifier_root_Dashboards_DataModifier_default = /*#__PURE__*/__webpack_require__.n(dashboards_DataModifier_commonjs_dashboards_DataModifier_commonjs2_dashboards_DataModifier_root_Dashboards_DataModifier_);\n;// ./code/dashboards/es-modules/Data/Modifiers/MathModifier.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *\n * */\n\n\n\n\n/* *\n *\n *  Class\n *\n * */\n/**\n * Replaces formula strings in a table with calculated values.\n *\n * @class\n * @name Highcharts.DataModifier.types.MathModifier\n * @augments Highcharts.DataModifier\n */\nclass MathModifier extends (dashboards_DataModifier_commonjs_dashboards_DataModifier_commonjs2_dashboards_DataModifier_root_Dashboards_DataModifier_default()) {\n    /* *\n     *\n     *  Constructor\n     *\n     * */\n    constructor(options) {\n        super();\n        this.options = {\n            ...MathModifier.defaultOptions,\n            ...options\n        };\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    modifyTable(table, eventDetail) {\n        const modifier = this;\n        modifier.emit({ type: 'modify', detail: eventDetail, table });\n        const alternativeSeparators = modifier.options.alternativeSeparators, formulaColumns = (modifier.options.formulaColumns ||\n            table.getColumnIds()), modified = table.getModified();\n        for (let i = 0, iEnd = formulaColumns.length, columnId; i < iEnd; ++i) {\n            columnId = formulaColumns[i];\n            if (formulaColumns.indexOf(columnId) >= 0) {\n                modified.setColumn(columnId, modifier.processColumn(table, columnId));\n            }\n        }\n        const columnFormulas = (modifier.options.columnFormulas || []);\n        for (let i = 0, iEnd = columnFormulas.length, columnFormula, formula; i < iEnd; ++i) {\n            columnFormula = columnFormulas[i];\n            formula = Formula_FormulaParser.parseFormula(columnFormula.formula, alternativeSeparators);\n            modified.setColumn(columnFormula.column, modifier.processColumnFormula(formula, table, columnFormula.rowStart, columnFormula.rowEnd));\n        }\n        modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n        return table;\n    }\n    /**\n     * Process a column by replacing formula strings with calculated values.\n     *\n     * @private\n     *\n     * @param {Highcharts.DataTable} table\n     * Table to extract column from and use as reference.\n     *\n     * @param {string} columnId\n     * Id of column to process.\n     *\n     * @param {number} rowIndex\n     * Row index to start the replacing process from.\n     *\n     * @return {Highcharts.DataTableColumn}\n     * Returns the processed table column.\n     */\n    processColumn(table, columnId, rowIndex = 0) {\n        const alternativeSeparators = this.options.alternativeSeparators, column = (table.getColumn(columnId, true) || [])\n            .slice(rowIndex > 0 ? rowIndex : 0);\n        for (let i = 0, iEnd = column.length, cacheFormula = [], cacheString = '', cell; i < iEnd; ++i) {\n            cell = column[i];\n            if (typeof cell === 'string' &&\n                cell[0] === '=') {\n                try {\n                    // Use cache while formula string is repetitive\n                    cacheFormula = (cacheString === cell ?\n                        cacheFormula :\n                        Formula_FormulaParser.parseFormula(cell.substring(1), alternativeSeparators));\n                    // Process parsed formula string\n                    column[i] =\n                        Formula_FormulaProcessor.processFormula(cacheFormula, table);\n                }\n                catch {\n                    column[i] = NaN;\n                }\n            }\n        }\n        return column;\n    }\n    /**\n     * Process a column by replacing cell values with calculated values from a\n     * given formula.\n     *\n     * @private\n     *\n     * @param {Highcharts.Formula} formula\n     * Formula to use for processing.\n     *\n     * @param {Highcharts.DataTable} table\n     * Table to extract column from and use as reference.\n     *\n     * @param {number} rowStart\n     * Row index to start the replacing process from.\n     *\n     * @param {number} rowEnd\n     * Row index to end the replacing process.\n     *\n     * @return {Highcharts.DataTableColumn}\n     * Returns the processed table column.\n     */\n    processColumnFormula(formula, table, rowStart = 0, rowEnd = table.getRowCount()) {\n        rowStart = rowStart >= 0 ? rowStart : 0;\n        rowEnd = rowEnd >= 0 ? rowEnd : table.getRowCount() + rowEnd;\n        const column = [], modified = table.getModified();\n        for (let i = 0, iEnd = (rowEnd - rowStart); i < iEnd; ++i) {\n            try {\n                column[i] = Formula_FormulaProcessor.processFormula(formula, modified);\n            }\n            catch {\n                column[i] = NaN;\n            }\n            finally {\n                formula = Formula_FormulaProcessor.translateReferences(formula, 0, 1);\n            }\n        }\n        return column;\n    }\n}\n/* *\n *\n *  Static Properties\n *\n * */\n/**\n * Default options of MathModifier.\n * @private\n */\nMathModifier.defaultOptions = {\n    type: 'Math',\n    alternativeSeparators: false\n};\ndashboards_DataModifier_commonjs_dashboards_DataModifier_commonjs2_dashboards_DataModifier_root_Dashboards_DataModifier_default().registerType('Math', MathModifier);\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const Modifiers_MathModifier = ((/* unused pure expression or super */ null && (MathModifier)));\n\n;// ./code/dashboards/es-modules/masters/modules/math-modifier.js\n\n\n/* *\n *\n *  Imports\n *\n * */\n\n\n// Fill registries\n\n/* *\n *\n *  Namespace\n *\n * */\nconst G = (dashboards_commonjs_dashboards_commonjs2_dashboards_root_Dashboards_default());\nG.Formula = Formula_Formula;\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ const math_modifier_src = (G);\n\n__webpack_exports__ = __webpack_exports__[\"default\"];\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"names":["root","factory","exports","module","define","amd","amd1","window","__WEBPACK_EXTERNAL_MODULE__668__","__WEBPACK_EXTERNAL_MODULE__784__","__webpack_modules__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","__webpack_exports__","math_modifier_src","dashboards_commonjs_dashboards_commonjs2_dashboards_root_Dashboards_","dashboards_commonjs_dashboards_commonjs2_dashboards_root_Dashboards_default","isString","booleanRegExp","decimal1RegExp","decimal2RegExp","functionRegExp","operatorRegExp","rangeA1RegExp","rangeR1C1RegExp","referenceA1RegExp","referenceR1C1RegExp","extractParantheses","text","parantheseLevel","i","iEnd","length","char","parantheseStart","substring","error","Error","name","extractString","start","escaping","parseArgument","alternativeSeparators","match","beginColumnRelative","beginRowRelative","endColumnRelative","endRowRelative","range","type","beginColumn","parseInt","beginRow","endColumn","endRow","parseReferenceColumn","formula","parseFormula","negativeReference","formulaLength","priorFormula","decimalRegExp","next","trim","columnRelative","rowRelative","reference","column","row","pop","isNegative","push","number","parseFloat","string","parantheses","args","parseArguments","argumentsSeparator","term","paranteses","position","code","factor","charCodeAt","Math","pow","Formula_FormulaParser","operators","FormulaTypes","isFormula","item","Array","isArray","isFunction","isOperator","indexOf","isRange","isReference","isValue","FormulaProcessor_isFormula","FormulaProcessor_isFunction","FormulaProcessor_isOperator","FormulaProcessor_isRange","FormulaProcessor_isReference","FormulaProcessor_isValue","defined","asLogicalStringRegExp","MAX_FALSE","Number","MAX_VALUE","MAX_STRING","MAX_TRUE","operatorPriority","processorFunctions","processorFunctionNameRegExp","asLogicalNumber","value","NaN","asLogicalString","toLowerCase","replace","asNumber","getArgumentValue","arg","table","getRangeValues","processFunction","processFormula","columnIds","getColumnIds","slice","values","cell","cells","getColumn","j","jEnd","getModified","getCell","getReferenceValue","columnId","result","applyOperator","secondValue","firstValue","operator","basicOperation","x","y","round","expectingValue","formulaFunction","processor","Formula_FormulaProcessor","getArgumentsValues","registerProcessorFunction","processorFunction","test","translateReferences","columnDelta","rowDelta","ABS_getArgumentValue","abs","value2","AND_getArgumentValue","AND","AVERAGE_getArgumentsValues","count","isNaN","AVERAGEA_getArgumentValue","COUNT","COUNTA","IF_getArgumentValue","ISNA_getArgumentValue","MAX_getArgumentsValues","MAX","isFinite","median","half","floor","MIN_getArgumentsValues","MIN","MOD_getArgumentValue","getModeMap","modeMap","SNGL","keys","modeKey","modeCount","keyValue","value1","modeKeys","NOT_getArgumentValue","OR_getArgumentValue","OR","PRODUCT_getArgumentsValues","PRODUCT","calculated","SUM","XOR_getArgumentValue","lastValue","Formula","dashboards_DataModifier_commonjs_dashboards_DataModifier_commonjs2_dashboards_DataModifier_root_Dashboards_DataModifier_","dashboards_DataModifier_commonjs_dashboards_DataModifier_commonjs2_dashboards_DataModifier_root_Dashboards_DataModifier_default","MathModifier","options","defaultOptions","modifyTable","eventDetail","modifier","emit","detail","formulaColumns","modified","setColumn","processColumn","columnFormulas","columnFormula","processColumnFormula","rowStart","rowEnd","rowIndex","cacheFormula","cacheString","getRowCount","registerType","G"],"mappings":"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"}