{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Dashboards Math 1.3.1 (2024-02-14)\n *\n * (c) 2009-2024 Highsoft AS\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('dashboards/modules/math-modifier', ['dashboards'], function (Dashboards) {\n            factory(Dashboards);\n            factory.Dashboards = Dashboards;\n            return factory;\n        });\n    } else {\n        factory(typeof Dashboards !== 'undefined' ? Dashboards : undefined);\n    }\n}(function (Dashboards) {\n    'use strict';\n    var _modules = Dashboards ? Dashboards._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'DashboardsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Data/Formula/FormulaParser.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * @private\n         */\n        const booleanRegExp = /^(?:FALSE|TRUE)/;\n        /**\n         * `.`-separated decimal.\n         * @private\n         */\n        const decimal1RegExp = /^[+-]?\\d+(?:\\.\\d+)?(?:e[+-]\\d+)?/;\n        /**\n         * `,`-separated decimal.\n         * @private\n         */\n        const decimal2RegExp = /^[+-]?\\d+(?:,\\d+)?(?:e[+-]\\d+)?/;\n        /**\n         * - Group 1: Function name\n         * @private\n         */\n        const functionRegExp = /^([A-Z][A-Z\\d\\.]*)\\(/;\n        /**\n         * @private\n         */\n        const operatorRegExp = /^(?:[+\\-*\\/^<=>]|<=|=>)/;\n        /**\n         * - Group 1: Start column\n         * - Group 2: Start row\n         * - Group 3: End column\n         * - Group 4: End row\n         * @private\n         */\n        const rangeA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)\\:(\\$?[A-Z]+)(\\$?\\d+)/;\n        /**\n         * - Group 1: Start row\n         * - Group 2: Start column\n         * - Group 3: End row\n         * - Group 4: End column\n         * @private\n         */\n        const rangeR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])\\:R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])/;\n        /**\n         * - Group 1: Column\n         * - Group 2: Row\n         * @private\n         */\n        const referenceA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)(?![\\:C])/;\n        /**\n         * - Group 1: Row\n         * - Group 2: Column\n         * @private\n         */\n        const referenceR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])(?!\\:)/;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Extracts the inner string of the most outer parantheses.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Text string to extract from.\n         *\n         * @return {string}\n         * Extracted parantheses. If not found an exception will be thrown.\n         */\n        function extractParantheses(text) {\n            let parantheseLevel = 0;\n            for (let i = 0, iEnd = text.length, char, parantheseStart = 1; i < iEnd; ++i) {\n                char = text[i];\n                if (char === '(') {\n                    if (!parantheseLevel) {\n                        parantheseStart = i + 1;\n                    }\n                    ++parantheseLevel;\n                    continue;\n                }\n                if (char === ')') {\n                    --parantheseLevel;\n                    if (!parantheseLevel) {\n                        return text.substring(parantheseStart, i);\n                    }\n                }\n            }\n            if (parantheseLevel > 0) {\n                const error = new Error('Incomplete parantheses.');\n                error.name = 'FormulaParseError';\n                throw error;\n            }\n            return '';\n        }\n        /**\n         * Extracts the inner string value.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Text string to extract from.\n         *\n         * @return {string}\n         * Extracted string. If not found an exception will be thrown.\n         */\n        function extractString(text) {\n            let start = -1;\n            for (let i = 0, iEnd = text.length, char, escaping = false; i < iEnd; ++i) {\n                char = text[i];\n                if (char === '\\\\') {\n                    escaping = !escaping;\n                    continue;\n                }\n                if (escaping) {\n                    escaping = false;\n                    continue;\n                }\n                if (char === '\"') {\n                    if (start < 0) {\n                        start = i;\n                    }\n                    else {\n                        return text.substring(start + 1, i); // i is excluding\n                    }\n                }\n            }\n            const error = new Error('Incomplete string.');\n            error.name = 'FormulaParseError';\n            throw error;\n        }\n        /**\n         * Parses an argument string. Formula arrays with a single term will be\n         * simplified to the term.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Argument string to parse.\n         *\n         * @param {boolean} alternativeSeparators\n         * Whether to expect `;` as argument separator and `,` as decimal separator.\n         *\n         * @return {Formula|Function|Range|Reference|Value}\n         * The recognized term structure.\n         */\n        function parseArgument(text, alternativeSeparators) {\n            let match;\n            // Check for a R1C1:R1C1 range notation\n            match = text.match(rangeR1C1RegExp);\n            if (match) {\n                const beginColumnRelative = (match[2] === '' || match[2][0] === '[');\n                const beginRowRelative = (match[1] === '' || match[1][0] === '[');\n                const endColumnRelative = (match[4] === '' || match[4][0] === '[');\n                const endRowRelative = (match[3] === '' || match[3][0] === '[');\n                const range = {\n                    type: 'range',\n                    beginColumn: (beginColumnRelative ?\n                        parseInt(match[2].substring(1, -1) || '0', 10) :\n                        parseInt(match[2], 10) - 1),\n                    beginRow: (beginRowRelative ?\n                        parseInt(match[1].substring(1, -1) || '0', 10) :\n                        parseInt(match[1], 10) - 1),\n                    endColumn: (endColumnRelative ?\n                        parseInt(match[4].substring(1, -1) || '0', 10) :\n                        parseInt(match[4], 10) - 1),\n                    endRow: (endRowRelative ?\n                        parseInt(match[3].substring(1, -1) || '0', 10) :\n                        parseInt(match[3], 10) - 1)\n                };\n                if (beginColumnRelative) {\n                    range.beginColumnRelative = true;\n                }\n                if (beginRowRelative) {\n                    range.beginRowRelative = true;\n                }\n                if (endColumnRelative) {\n                    range.endColumnRelative = true;\n                }\n                if (endRowRelative) {\n                    range.endRowRelative = true;\n                }\n                return range;\n            }\n            // Check for a A1:A1 range notation\n            match = text.match(rangeA1RegExp);\n            if (match) {\n                const beginColumnRelative = match[1][0] !== '$';\n                const beginRowRelative = match[2][0] !== '$';\n                const endColumnRelative = match[3][0] !== '$';\n                const endRowRelative = match[4][0] !== '$';\n                const range = {\n                    type: 'range',\n                    beginColumn: parseReferenceColumn(beginColumnRelative ?\n                        match[1] :\n                        match[1].substring(1)) - 1,\n                    beginRow: parseInt(beginRowRelative ?\n                        match[2] :\n                        match[2].substring(1), 10) - 1,\n                    endColumn: parseReferenceColumn(endColumnRelative ?\n                        match[3] :\n                        match[3].substring(1)) - 1,\n                    endRow: parseInt(endRowRelative ?\n                        match[4] :\n                        match[4].substring(1), 10) - 1\n                };\n                if (beginColumnRelative) {\n                    range.beginColumnRelative = true;\n                }\n                if (beginRowRelative) {\n                    range.beginRowRelative = true;\n                }\n                if (endColumnRelative) {\n                    range.endColumnRelative = true;\n                }\n                if (endRowRelative) {\n                    range.endRowRelative = true;\n                }\n                return range;\n            }\n            // Fallback to formula processing for other pattern types\n            const formula = parseFormula(text, alternativeSeparators);\n            return (formula.length === 1 && typeof formula[0] !== 'string' ?\n                formula[0] :\n                formula);\n        }\n        /**\n         * Parse arguments string inside function parantheses.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Parantheses string of the function.\n         *\n         * @param {boolean} alternativeSeparators\n         * Whether to expect `;` as argument separator and `,` as decimal separator.\n         *\n         * @return {Highcharts.FormulaArguments}\n         * Parsed arguments array.\n         */\n        function parseArguments(text, alternativeSeparators) {\n            const args = [], argumentsSeparator = (alternativeSeparators ? ';' : ',');\n            let parantheseLevel = 0, term = '';\n            for (let i = 0, iEnd = text.length, char; i < iEnd; ++i) {\n                char = text[i];\n                // Check for separator\n                if (char === argumentsSeparator &&\n                    !parantheseLevel &&\n                    term) {\n                    args.push(parseArgument(term, alternativeSeparators));\n                    term = '';\n                    // Check for a quoted string before skip logic\n                }\n                else if (char === '\"' &&\n                    !parantheseLevel &&\n                    !term) {\n                    const string = extractString(text.substring(i));\n                    args.push(string);\n                    i += string.length + 1; // only +1 to cover ++i in for-loop\n                    // Skip space and check paranthesis nesting\n                }\n                else if (char !== ' ') {\n                    term += char;\n                    if (char === '(') {\n                        ++parantheseLevel;\n                    }\n                    else if (char === ')') {\n                        --parantheseLevel;\n                    }\n                }\n            }\n            // look for left-overs from last argument\n            if (!parantheseLevel && term) {\n                args.push(parseArgument(term, alternativeSeparators));\n            }\n            return args;\n        }\n        /**\n         * Converts a spreadsheet formula string into a formula array. Throws a\n         * `FormulaParserError` when the string can not be parsed.\n         *\n         * @private\n         * @function Formula.parseFormula\n         *\n         * @param {string} text\n         * Spreadsheet formula string, without the leading `=`.\n         *\n         * @param {boolean} alternativeSeparators\n         * * `false` to expect `,` between arguments and `.` in decimals.\n         * * `true` to expect `;` between arguments and `,` in decimals.\n         *\n         * @return {Formula.Formula}\n         * Formula array representing the string.\n         */\n        function parseFormula(text, alternativeSeparators) {\n            const decimalRegExp = (alternativeSeparators ?\n                decimal2RegExp :\n                decimal1RegExp), formula = [];\n            let match, next = (text[0] === '=' ? text.substring(1) : text).trim();\n            while (next) {\n                // Check for an R1C1 reference notation\n                match = next.match(referenceR1C1RegExp);\n                if (match) {\n                    const columnRelative = (match[2] === '' || match[2][0] === '[');\n                    const rowRelative = (match[1] === '' || match[1][0] === '[');\n                    const reference = {\n                        type: 'reference',\n                        column: (columnRelative ?\n                            parseInt(match[2].substring(1, -1) || '0', 10) :\n                            parseInt(match[2], 10) - 1),\n                        row: (rowRelative ?\n                            parseInt(match[1].substring(1, -1) || '0', 10) :\n                            parseInt(match[1], 10) - 1)\n                    };\n                    if (columnRelative) {\n                        reference.columnRelative = true;\n                    }\n                    if (rowRelative) {\n                        reference.rowRelative = true;\n                    }\n                    formula.push(reference);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for an A1 reference notation\n                match = next.match(referenceA1RegExp);\n                if (match) {\n                    const columnRelative = match[1][0] !== '$';\n                    const rowRelative = match[2][0] !== '$';\n                    const reference = {\n                        type: 'reference',\n                        column: parseReferenceColumn(columnRelative ?\n                            match[1] :\n                            match[1].substring(1)) - 1,\n                        row: parseInt(rowRelative ?\n                            match[2] :\n                            match[2].substring(1), 10) - 1\n                    };\n                    if (columnRelative) {\n                        reference.columnRelative = true;\n                    }\n                    if (rowRelative) {\n                        reference.rowRelative = true;\n                    }\n                    formula.push(reference);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a formula operator\n                match = next.match(operatorRegExp);\n                if (match) {\n                    formula.push(match[0]);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a boolean value\n                match = next.match(booleanRegExp);\n                if (match) {\n                    formula.push(match[0] === 'TRUE');\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a number value\n                match = next.match(decimalRegExp);\n                if (match) {\n                    formula.push(parseFloat(match[0]));\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a quoted string\n                if (next[0] === '\"') {\n                    const string = extractString(next);\n                    formula.push(string.substring(1, -1));\n                    next = next.substring(string.length + 2).trim();\n                    continue;\n                }\n                // Check for a function\n                match = next.match(functionRegExp);\n                if (match) {\n                    next = next.substring(match[1].length).trim();\n                    const parantheses = extractParantheses(next);\n                    formula.push({\n                        type: 'function',\n                        name: match[1],\n                        args: parseArguments(parantheses, alternativeSeparators)\n                    });\n                    next = next.substring(parantheses.length + 2).trim();\n                    continue;\n                }\n                // Check for a formula in parantheses\n                if (next[0] === '(') {\n                    const paranteses = extractParantheses(next);\n                    if (paranteses) {\n                        formula\n                            .push(parseFormula(paranteses, alternativeSeparators));\n                        next = next.substring(paranteses.length + 2).trim();\n                        continue;\n                    }\n                }\n                // Something is not right\n                const position = text.length - next.length, error = new Error('Unexpected character `' +\n                    text.substring(position, position + 1) +\n                    '` at position ' + (position + 1) +\n                    '. (`...' + text.substring(position - 5, position + 6) + '...`)');\n                error.name = 'FormulaParseError';\n                throw error;\n            }\n            return formula;\n        }\n        /**\n         * Converts a reference column `A` of `A1` into a number. Supports endless sizes\n         * `ZZZ...`, just limited by integer precision.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Column string to convert.\n         *\n         * @return {number}\n         * Converted column index.\n         */\n        function parseReferenceColumn(text) {\n            let column = 0;\n            for (let i = 0, iEnd = text.length, code, factor = text.length - 1; i < iEnd; ++i) {\n                code = text.charCodeAt(i);\n                if (code >= 65 && code <= 90) {\n                    column += (code - 64) * Math.pow(26, factor);\n                }\n                --factor;\n            }\n            return column;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const FormulaParser = {\n            parseFormula\n        };\n\n        return FormulaParser;\n    });\n    _registerModule(_modules, 'Data/Formula/FormulaTypes.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * Array of all possible operators.\n         * @private\n         */\n        const operators = ['+', '-', '*', '/', '^', '=', '<', '<=', '>', '>='];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Tests an item for a Formula array.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a formula (or argument) array.\n         */\n        function isFormula(item) {\n            return item instanceof Array;\n        }\n        /**\n         * Tests an item for a Function structure.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a formula function.\n         */\n        function isFunction(item) {\n            return (typeof item === 'object' &&\n                !(item instanceof Array) &&\n                item.type === 'function');\n        }\n        /**\n         * Tests an item for an Operator string.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is an operator string.\n         */\n        function isOperator(item) {\n            return (typeof item === 'string' &&\n                operators.indexOf(item) >= 0);\n        }\n        /**\n         * Tests an item for a Range structure.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a range.\n         */\n        function isRange(item) {\n            return (typeof item === 'object' &&\n                !(item instanceof Array) &&\n                item.type === 'range');\n        }\n        /**\n         * Tests an item for a Reference structure.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a reference.\n         */\n        function isReference(item) {\n            return (typeof item === 'object' &&\n                !(item instanceof Array) &&\n                item.type === 'reference');\n        }\n        /**\n         * Tests an item for a Value structure.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem|null|undefined} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a value.\n         */\n        function isValue(item) {\n            return (typeof item === 'boolean' ||\n                typeof item === 'number' ||\n                typeof item === 'string');\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MathFormula = {\n            isFormula,\n            isFunction,\n            isOperator,\n            isRange,\n            isReference,\n            isValue\n        };\n\n        return MathFormula;\n    });\n    _registerModule(_modules, 'Data/Formula/FormulaProcessor.js', [_modules['Data/Formula/FormulaTypes.js']], function (FormulaTypes) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { isFormula, isFunction, isOperator, isRange, isReference, isValue } = FormulaTypes;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const asLogicalStringRegExp = / */;\n        const MAX_FALSE = Number.MAX_VALUE / 1.000000000001;\n        const MAX_STRING = Number.MAX_VALUE / 1.000000000002;\n        const MAX_TRUE = Number.MAX_VALUE;\n        const operatorPriority = {\n            '^': 3,\n            '*': 2,\n            '/': 2,\n            '+': 1,\n            '-': 1,\n            '=': 0,\n            '<': 0,\n            '<=': 0,\n            '>': 0,\n            '>=': 0\n        };\n        const processorFunctions = {};\n        const processorFunctionNameRegExp = /^[A-Z][A-Z\\.]*$/;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Converts non-number types to logical numbers.\n         *\n         * @param {Highcharts.FormulaValue} value\n         * Value to convert.\n         *\n         * @return {number}\n         * Logical number value. `NaN` if not convertable.\n         */\n        function asLogicalNumber(value) {\n            switch (typeof value) {\n                case 'boolean':\n                    return value ? MAX_TRUE : MAX_FALSE;\n                case 'string':\n                    return MAX_STRING;\n                case 'number':\n                    return value;\n                default:\n                    return NaN;\n            }\n        }\n        /**\n         * Converts strings to logical strings, while other types get passed through. In\n         * logical strings the space character is the lowest value and letters are case\n         * insensitive.\n         *\n         * @param {Highcharts.FormulaValue} value\n         * Value to convert.\n         *\n         * @return {Highcharts.FormulaValue}\n         * Logical string value or passed through value.\n         */\n        function asLogicalString(value) {\n            if (typeof value === 'string') {\n                return value.toLowerCase().replace(asLogicalStringRegExp, '\\0');\n            }\n            return value;\n        }\n        /**\n         * Converts non-number types to a logic number.\n         *\n         * @param {Highcharts.FormulaValue} value\n         * Value to convert.\n         *\n         * @return {number}\n         * Number value. `NaN` if not convertable.\n         */\n        function asNumber(value) {\n            switch (typeof value) {\n                case 'boolean':\n                    return value ? 1 : 0;\n                case 'string':\n                    return parseFloat(value.replace(',', '.'));\n                case 'number':\n                    return value;\n                default:\n                    return NaN;\n            }\n        }\n        /**\n         * Process a basic operation of two given values.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaOperator} operator\n         * Operator between values.\n         *\n         * @param {Highcharts.FormulaValue} x\n         * First value for operation.\n         *\n         * @param {Highcharts.FormulaValue} y\n         * Second value for operation.\n         *\n         * @return {Highcharts.FormulaValue}\n         * Operation result. `NaN` if operation is not support.\n         */\n        function basicOperation(operator, x, y) {\n            switch (operator) {\n                case '=':\n                    return asLogicalString(x) === asLogicalString(y);\n                case '<':\n                    if (typeof x === typeof y) {\n                        return asLogicalString(x) < asLogicalString(y);\n                    }\n                    return asLogicalNumber(x) < asLogicalNumber(y);\n                case '<=':\n                    if (typeof x === typeof y) {\n                        return asLogicalString(x) <= asLogicalString(y);\n                    }\n                    return asLogicalNumber(x) <= asLogicalNumber(y);\n                case '>':\n                    if (typeof x === typeof y) {\n                        return asLogicalString(x) > asLogicalString(y);\n                    }\n                    return asLogicalNumber(x) > asLogicalNumber(y);\n                case '>=':\n                    if (typeof x === typeof y) {\n                        return asLogicalString(x) >= asLogicalString(y);\n                    }\n                    return asLogicalNumber(x) >= asLogicalNumber(y);\n            }\n            x = asNumber(x);\n            y = asNumber(y);\n            let result;\n            switch (operator) {\n                case '+':\n                    result = x + y;\n                    break;\n                case '-':\n                    result = x - y;\n                    break;\n                case '*':\n                    result = x * y;\n                    break;\n                case '/':\n                    result = x / y;\n                    break;\n                case '^':\n                    result = Math.pow(x, y);\n                    break;\n                default:\n                    return NaN;\n            }\n            // limit decimal to 9 digits\n            return (result % 1 ?\n                Math.round(result * 1000000000) / 1000000000 :\n                result);\n        }\n        /**\n         * Converts an argument to Value and in case of a range to an array of Values.\n         *\n         * @function Highcharts.Formula.getArgumentValue\n         *\n         * @param {Highcharts.FormulaRange|Highcharts.FormulaTerm} arg\n         * Formula range or term to convert.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n         * Converted value.\n         */\n        function getArgumentValue(arg, table) {\n            // Add value\n            if (isValue(arg)) {\n                return arg;\n            }\n            // Add values of a range\n            if (isRange(arg)) {\n                return (table && getRangeValues(arg, table) || []);\n            }\n            // Add values of a function\n            if (isFunction(arg)) {\n                return processFunction(arg, table);\n            }\n            // Process functions, operations, references with formula processor\n            return processFormula((isFormula(arg) ? arg : [arg]), table);\n        }\n        /**\n         * Converts all arguments to Values and in case of ranges to arrays of Values.\n         *\n         * @function Highcharts.Formula.getArgumentsValues\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Formula arguments to convert.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Array<(Highcharts.FormulaValue|Array<Highcharts.FormulaValue>)>}\n         * Converted values.\n         */\n        function getArgumentsValues(args, table) {\n            const values = [];\n            for (let i = 0, iEnd = args.length; i < iEnd; ++i) {\n                values.push(getArgumentValue(args[i], table));\n            }\n            return values;\n        }\n        /**\n         * Extracts cell values from a table for a given range.\n         *\n         * @function Highcharts.Formula.getRangeValues\n         *\n         * @param {Highcharts.FormulaRange} range\n         * Formula range to use.\n         *\n         * @param {Highcharts.DataTable} table\n         * Table to extract from.\n         *\n         * @return {Array<Highcharts.FormulaValue>}\n         * Extracted values.\n         */\n        function getRangeValues(range, table) {\n            const columnNames = table\n                .getColumnNames()\n                .slice(range.beginColumn, range.endColumn + 1), values = [];\n            for (let i = 0, iEnd = columnNames.length, cell; i < iEnd; ++i) {\n                const cells = table.getColumn(columnNames[i], true) || [];\n                for (let j = range.beginRow, jEnd = range.endRow + 1; j < jEnd; ++j) {\n                    cell = cells[j];\n                    if (typeof cell === 'string' &&\n                        cell[0] === '=' &&\n                        table !== table.modified) {\n                        // Look in the modified table for formula result\n                        cell = table.modified.getCell(columnNames[i], j);\n                    }\n                    values.push(isValue(cell) ? cell : NaN);\n                }\n            }\n            return values;\n        }\n        /**\n         * Extracts the cell value from a table for a given reference.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaReference} reference\n         * Formula reference to use.\n         *\n         * @param {Highcharts.DataTable} table\n         * Table to extract from.\n         *\n         * @return {Highcharts.FormulaValue}\n         * Extracted value. 'undefined' might also indicate that the cell was not found.\n         */\n        function getReferenceValue(reference, table) {\n            const columnName = table.getColumnNames()[reference.column];\n            if (columnName) {\n                const cell = table.getCell(columnName, reference.row);\n                if (typeof cell === 'string' &&\n                    cell[0] === '=' &&\n                    table !== table.modified) {\n                    // Look in the modified table for formula result\n                    const result = table.modified.getCell(columnName, reference.row);\n                    return isValue(result) ? result : NaN;\n                }\n                return isValue(cell) ? cell : NaN;\n            }\n            return NaN;\n        }\n        /**\n         * Processes a formula array on the given table. If the formula does not contain\n         * references or ranges, then no table has to be provided.\n         *\n         * @private\n         * @function Highcharts.processFormula\n         *\n         * @param {Highcharts.Formula} formula\n         * Formula array to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Highcharts.FormulaValue}\n         * Result value of the process. `NaN` indicates an error.\n         */\n        function processFormula(formula, table) {\n            let x;\n            for (let i = 0, iEnd = formula.length, item, operator, result, y; i < iEnd; ++i) {\n                item = formula[i];\n                // Remember operator for operation on next item\n                if (isOperator(item)) {\n                    operator = item;\n                    continue;\n                }\n                // Next item is a value\n                if (isValue(item)) {\n                    y = item;\n                    // Next item is a formula and needs to get processed first\n                }\n                else if (isFormula(item)) {\n                    y = processFormula(formula, table);\n                    // Next item is a function call and needs to get processed first\n                }\n                else if (isFunction(item)) {\n                    result = processFunction(item, table);\n                    y = (isValue(result) ? result : NaN); // arrays are not allowed here\n                    // Next item is a reference and needs to get resolved\n                }\n                else if (isReference(item)) {\n                    y = (table && getReferenceValue(item, table));\n                }\n                // If we have a next value, lets do the operation\n                if (typeof y !== 'undefined') {\n                    // Next value is our first value\n                    if (typeof x === 'undefined') {\n                        if (operator) {\n                            x = basicOperation(operator, 0, y);\n                        }\n                        else {\n                            x = y;\n                        }\n                        // Fail fast if no operator available\n                    }\n                    else if (!operator) {\n                        return NaN;\n                        // Regular next value\n                    }\n                    else {\n                        const operator2 = formula[i + 1];\n                        if (isOperator(operator2) &&\n                            operatorPriority[operator2] > operatorPriority[operator]) {\n                            y = basicOperation(operator2, y, processFormula(formula.slice(i + 2)));\n                            i = iEnd;\n                        }\n                        x = basicOperation(operator, x, y);\n                    }\n                    operator = void 0;\n                    y = void 0;\n                }\n            }\n            return isValue(x) ? x : NaN;\n        }\n        /**\n         * Process a function  on the give table. If the arguments do not contain\n         * references or ranges, then no table has to be provided.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaFunction} formulaFunction\n         * Formula function to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @param {Highcharts.FormulaReference} [reference]\n         * Table cell reference to use for relative references and ranges.\n         *\n         * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n         * Result value (or values) of the process. `NaN` indicates an error.\n         */\n        function processFunction(formulaFunction, table, \n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        reference // @todo\n        ) {\n            const processor = processorFunctions[formulaFunction.name];\n            if (processor) {\n                try {\n                    return processor(formulaFunction.args, table);\n                }\n                catch {\n                    return NaN;\n                }\n            }\n            const error = new Error(`Function \"${formulaFunction.name}\" not found.`);\n            error.name = 'FormulaProcessError';\n            throw error;\n        }\n        /**\n         * Registers a function for the FormulaProcessor.\n         *\n         * @param {string} name\n         * Name of the function in spreadsheets notation with upper case.\n         *\n         * @param {Highcharts.FormulaFunction} processorFunction\n         * ProcessorFunction for the FormulaProcessor. This is an object so that it\n         * can take additional parameter for future validation routines.\n         *\n         * @return {boolean}\n         * Return true, if the ProcessorFunction has been registered.\n         */\n        function registerProcessorFunction(name, processorFunction) {\n            return (processorFunctionNameRegExp.test(name) &&\n                !processorFunctions[name] &&\n                !!(processorFunctions[name] = processorFunction));\n        }\n        /**\n         * Translates relative references and ranges in-place.\n         *\n         * @param {Highcharts.Formula} formula\n         * Formula to translate references and ranges in.\n         *\n         * @param {number} [columnDelta=0]\n         * Column delta to translate to. Negative translate back.\n         *\n         * @param {number} [rowDelta=0]\n         * Row delta to translate to. Negative numbers translate back.\n         *\n         * @return {Highcharts.Formula}\n         * Formula with translated reference and ranges. This formula is equal to the\n         * first argument.\n         */\n        function translateReferences(formula, columnDelta = 0, rowDelta = 0) {\n            for (let i = 0, iEnd = formula.length, item; i < iEnd; ++i) {\n                item = formula[i];\n                if (item instanceof Array) {\n                    translateReferences(item, columnDelta, rowDelta);\n                }\n                else if (isFunction(item)) {\n                    translateReferences(item.args, columnDelta, rowDelta);\n                }\n                else if (isRange(item)) {\n                    if (item.beginColumnRelative) {\n                        item.beginColumn += columnDelta;\n                    }\n                    if (item.beginRowRelative) {\n                        item.beginRow += rowDelta;\n                    }\n                    if (item.endColumnRelative) {\n                        item.endColumn += columnDelta;\n                    }\n                    if (item.endRowRelative) {\n                        item.endRow += rowDelta;\n                    }\n                }\n                else if (isReference(item)) {\n                    if (item.columnRelative) {\n                        item.column += columnDelta;\n                    }\n                    if (item.rowRelative) {\n                        item.row += rowDelta;\n                    }\n                }\n            }\n            return formula;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const FormulaProcessor = {\n            asNumber,\n            getArgumentValue,\n            getArgumentsValues,\n            getRangeValues,\n            getReferenceValue,\n            processFormula,\n            processorFunctions,\n            registerProcessorFunction,\n            translateReferences\n        };\n\n        return FormulaProcessor;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/ABS.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `ABS(value)` implementation. Returns positive numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Array<number>}\n         * Result value of the process.\n         */\n        function ABS(args, table) {\n            const value = getArgumentValue(args[0], table);\n            switch (typeof value) {\n                case 'number':\n                    return Math.abs(value);\n                case 'object': {\n                    const values = [];\n                    for (let i = 0, iEnd = value.length, value2; i < iEnd; ++i) {\n                        value2 = value[i];\n                        if (typeof value2 !== 'number') {\n                            return NaN;\n                        }\n                        values.push(Math.abs(value2));\n                    }\n                    return values;\n                }\n                default:\n                    return NaN;\n            }\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('ABS', ABS);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ABS;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AND.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AND(...tests)` implementation. Returns `TRUE`, if all test\n         * results are not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function AND(args, table) {\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                if (!value ||\n                    (typeof value === 'object' &&\n                        !AND(value, table))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AND', AND);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AND;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AVERAGE.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentsValues } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AVERAGE(...values)` implementation. Calculates the average\n         * of the given values that are numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.AVERAGE\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function AVERAGE(args, table) {\n            const values = getArgumentsValues(args, table);\n            let count = 0, result = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            ++count;\n                            result += value;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            if (typeof value2 === 'number' &&\n                                !isNaN(value2)) {\n                                ++count;\n                                result += value2;\n                            }\n                        }\n                        break;\n                }\n            }\n            return (count ? (result / count) : 0);\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AVERAGE', AVERAGE);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AVERAGE;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AVERAGEA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AVERAGEA(...values)` implementation. Calculates the\n         * average of the given values. Strings and FALSE are calculated as 0.\n         *\n         * @private\n         * @function Formula.processorFunctions.AVERAGEA\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function AVERAGEA(args, table) {\n            let count = 0, result = 0;\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                switch (typeof value) {\n                    case 'boolean':\n                        ++count;\n                        result += (value ? 1 : 0);\n                        continue;\n                    case 'number':\n                        if (!isNaN(value)) {\n                            ++count;\n                            result += value;\n                        }\n                        continue;\n                    case 'string':\n                        ++count;\n                        continue;\n                    default:\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            switch (typeof value2) {\n                                case 'boolean':\n                                    ++count;\n                                    result += (value2 ? 1 : 0);\n                                    continue;\n                                case 'number':\n                                    if (!isNaN(value2)) {\n                                        ++count;\n                                        result += value2;\n                                    }\n                                    continue;\n                                case 'string':\n                                    ++count;\n                                    continue;\n                            }\n                        }\n                        continue;\n                }\n            }\n            return (count ? (result / count) : 0);\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AVERAGEA', AVERAGEA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AVERAGEA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/COUNT.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `COUNT(...values)` implementation. Returns the count of\n         * given values that are numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.COUNT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function COUNT(args, table) {\n            const values = FormulaProcessor.getArgumentsValues(args, table);\n            let count = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            ++count;\n                        }\n                        break;\n                    case 'object':\n                        count += COUNT(value, table);\n                        break;\n                }\n            }\n            return count;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('COUNT', COUNT);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return COUNT;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/COUNTA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `COUNTA(...values)` implementation. Returns the count of\n         * given values that are not empty.\n         *\n         * @private\n         * @function Formula.processorFunctions.COUNT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function COUNTA(args, table) {\n            const values = FormulaProcessor.getArgumentsValues(args, table);\n            let count = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (isNaN(value)) {\n                            continue;\n                        }\n                        break;\n                    case 'object':\n                        count += COUNTA(value, table);\n                        continue;\n                    case 'string':\n                        if (!value) {\n                            continue;\n                        }\n                        break;\n                }\n                ++count;\n            }\n            return count;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('COUNTA', COUNTA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return COUNTA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/IF.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `IF(test, value1, value2)` implementation. Returns one of\n         * the values based on the test result. `value1` will be returned, if the test\n         * result is not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.IF\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n         * Result value of the process.\n         */\n        function IF(args, table) {\n            return (getArgumentValue(args[0], table) ?\n                getArgumentValue(args[1], table) :\n                getArgumentValue(args[2], table));\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('IF', IF);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return IF;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/ISNA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `ISNA(value)` implementation. Returns TRUE if value is not\n         * a number.\n         *\n         * @private\n         * @function Formula.processorFunctions.ISNA\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function ISNA(args, table) {\n            const value = getArgumentValue(args[0], table);\n            return (typeof value !== 'number' || isNaN(value));\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('ISNA', ISNA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ISNA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MAX.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentsValues } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MAX(...values)` implementation. Calculates the largest\n         * of the given values that are numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.MAX\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MAX(args, table) {\n            const values = getArgumentsValues(args, table);\n            let result = Number.NEGATIVE_INFINITY;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (value > result) {\n                            result = value;\n                        }\n                        break;\n                    case 'object':\n                        value = MAX(value);\n                        if (value > result) {\n                            result = value;\n                        }\n                        break;\n                }\n            }\n            return isFinite(result) ? result : 0;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MAX', MAX);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MAX;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MEDIAN.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MEDIAN(...values)` implementation. Calculates the median\n         * average of the given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MEDIAN\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MEDIAN(args, table) {\n            const median = [], values = FormulaProcessor.getArgumentsValues(args, table);\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            median.push(value);\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            if (typeof value2 === 'number' &&\n                                !isNaN(value2)) {\n                                median.push(value2);\n                            }\n                        }\n                        break;\n                }\n            }\n            const count = median.length;\n            if (!count) {\n                return NaN;\n            }\n            const half = Math.floor(count / 2); // floor because index starts at 0\n            return (count % 2 ?\n                median[half] : // odd\n                (median[half - 1] + median[half]) / 2 // even\n            );\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MEDIAN', MEDIAN);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MEDIAN;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MIN.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentsValues } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MIN(...values)` implementation. Calculates the lowest\n         * of the given values that are numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.MIN\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MIN(args, table) {\n            const values = getArgumentsValues(args, table);\n            let result = Number.POSITIVE_INFINITY;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (value < result) {\n                            result = value;\n                        }\n                        break;\n                    case 'object':\n                        value = MIN(value);\n                        if (value < result) {\n                            result = value;\n                        }\n                        break;\n                }\n            }\n            return isFinite(result) ? result : 0;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MIN', MIN);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MIN;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MOD.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MOD(value1, value2)` implementation. Calculates the rest\n         * of the division with the given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MOD\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MOD(args, table) {\n            let value1 = getArgumentValue(args[0], table), value2 = getArgumentValue(args[1], table);\n            if (typeof value1 === 'object') {\n                value1 = value1[0];\n            }\n            if (typeof value2 === 'object') {\n                value2 = value2[0];\n            }\n            if (typeof value1 !== 'number' ||\n                typeof value2 !== 'number' ||\n                value2 === 0) {\n                return NaN;\n            }\n            return value1 % value2;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MOD', MOD);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MOD;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MODE.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates the mode map of the given arguments.\n         *\n         * @private\n         * @function Formula.processorFunctions.MULT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function getModeMap(args, table) {\n            const modeMap = {}, values = FormulaProcessor.getArgumentsValues(args, table);\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            modeMap[value] = (modeMap[value] || 0) + 1;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            if (typeof value2 === 'number' &&\n                                !isNaN(value2)) {\n                                modeMap[value2] = (modeMap[value2] || 0) + 1;\n                            }\n                        }\n                        break;\n                }\n            }\n            return modeMap;\n        }\n        /**\n         * Processor for the `MODE.MULT(...values)` implementation. Calculates the most\n         * frequent values of the give values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MULT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number|Array<number>}\n         * Result value of the process.\n         */\n        function MULT(args, table) {\n            const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n            if (!keys.length) {\n                return NaN;\n            }\n            let modeKeys = [parseFloat(keys[0])], modeCount = modeMap[keys[0]];\n            for (let i = 1, iEnd = keys.length, key, count; i < iEnd; ++i) {\n                key = keys[i];\n                count = modeMap[key];\n                if (modeCount < count) {\n                    modeKeys = [parseFloat(key)];\n                    modeCount = count;\n                }\n                else if (modeCount === count) {\n                    modeKeys.push(parseFloat(key));\n                }\n            }\n            return modeCount > 1 ? modeKeys : NaN;\n        }\n        /**\n         * Processor for the `MODE.SNGL(...values)` implementation. Calculates the\n         * lowest most frequent value of the give values.\n         *\n         * @private\n         * @function Formula.processorFunctions['MODE.SNGL']\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function SNGL(args, table) {\n            const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n            if (!keys.length) {\n                return NaN;\n            }\n            let modeKey = parseFloat(keys[0]), modeCount = modeMap[keys[0]];\n            for (let i = 1, iEnd = keys.length, key, keyValue, count; i < iEnd; ++i) {\n                key = keys[i];\n                count = modeMap[key];\n                if (modeCount < count) {\n                    modeKey = parseFloat(key);\n                    modeCount = count;\n                }\n                else if (modeCount === count) {\n                    keyValue = parseFloat(key);\n                    if (modeKey > keyValue) {\n                        modeKey = keyValue;\n                        modeCount = count;\n                    }\n                }\n            }\n            return modeCount > 1 ? modeKey : NaN;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MODE', SNGL);\n        FormulaProcessor.registerProcessorFunction('MODE.MULT', MULT);\n        FormulaProcessor.registerProcessorFunction('MODE.SNGL', SNGL);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MODE = {\n            MULT,\n            SNGL\n        };\n\n        return MODE;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/NOT.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `NOT(value)` implementation. Returns the opposite test\n         * result.\n         *\n         * @private\n         * @function Formula.processorFunctions.NOT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean|number}\n         * Result value of the process.\n         */\n        function NOT(args, table) {\n            let value = getArgumentValue(args[0], table);\n            if (typeof value === 'object') {\n                value = value[0];\n            }\n            switch (typeof value) {\n                case 'boolean':\n                case 'number':\n                    return !value;\n            }\n            return NaN;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('NOT', NOT);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return NOT;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/OR.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `OR(...tests)` implementation. Returns `TRUE`, if one test\n         * result is not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function OR(args, table) {\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                if (typeof value === 'object') {\n                    if (OR(value, table)) {\n                        return true;\n                    }\n                }\n                else if (value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('OR', OR);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return OR;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/PRODUCT.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentsValues } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `PRODUCT(...values)` implementation. Calculates the product\n         * of the given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.PRODUCT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function PRODUCT(args, table) {\n            const values = getArgumentsValues(args, table);\n            let result = 1, calculated = false;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            calculated = true;\n                            result *= value;\n                        }\n                        break;\n                    case 'object':\n                        calculated = true;\n                        result *= PRODUCT(value, table);\n                        break;\n                }\n            }\n            return (calculated ? result : 0);\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('PRODUCT', PRODUCT);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return PRODUCT;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/SUM.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `SUM(...values)` implementation. Calculates the sum of the\n         * given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.SUM\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function SUM(args, table) {\n            const values = FormulaProcessor.getArgumentsValues(args, table);\n            let result = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            result += value;\n                        }\n                        break;\n                    case 'object':\n                        result += SUM(value, table);\n                        break;\n                }\n            }\n            return result;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('SUM', SUM); // 🐝\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SUM;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/XOR.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `XOR(...tests)` implementation. Returns `TRUE`, if at least\n         * one of the given tests differs in result of other tests.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean|number}\n         * Result value of the process.\n         */\n        function XOR(args, table) {\n            for (let i = 0, iEnd = args.length, lastValue, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                switch (typeof value) {\n                    case 'boolean':\n                    case 'number':\n                        if (typeof lastValue === 'undefined') {\n                            lastValue = !!value;\n                        }\n                        else if (!!value !== lastValue) {\n                            return true;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            switch (typeof value2) {\n                                case 'boolean':\n                                case 'number':\n                                    if (typeof lastValue === 'undefined') {\n                                        lastValue = !!value2;\n                                    }\n                                    else if (!!value2 !== lastValue) {\n                                        return true;\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                }\n            }\n            return false;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('XOR', XOR);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return XOR;\n    });\n    _registerModule(_modules, 'Data/Formula/Formula.js', [_modules['Data/Formula/FormulaParser.js'], _modules['Data/Formula/FormulaProcessor.js'], _modules['Data/Formula/FormulaTypes.js']], function (FormulaParser, FormulaProcessor, FormulaType) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /**\n         * Formula engine to make use of spreadsheet formula strings.\n         * @internal\n         */\n        const Formula = {\n            ...FormulaParser,\n            ...FormulaProcessor,\n            ...FormulaType\n        };\n\n        return Formula;\n    });\n    _registerModule(_modules, 'Data/Modifiers/MathModifier.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Data/Formula/FormulaParser.js'], _modules['Data/Formula/FormulaProcessor.js']], function (DataModifier, FormulaParser, FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Replaces formula strings in a table with calculated values.\n         *\n         * @private\n         * @class\n         * @name Highcharts.DataModifier.types.MathModifier\n         * @augments Highcharts.DataModifier\n         */\n        class MathModifier extends DataModifier {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(options) {\n                super();\n                this.options = {\n                    ...MathModifier.defaultOptions,\n                    ...options\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            modifyTable(table, eventDetail) {\n                const modifier = this;\n                modifier.emit({ type: 'modify', detail: eventDetail, table });\n                const alternativeSeparators = modifier.options.alternativeSeparators, formulaColumns = (modifier.options.formulaColumns ||\n                    table.getColumnNames()), modified = table.modified;\n                for (let i = 0, iEnd = formulaColumns.length, columnName; i < iEnd; ++i) {\n                    columnName = formulaColumns[i];\n                    if (formulaColumns.indexOf(columnName) >= 0) {\n                        modified.setColumn(columnName, modifier.processColumn(table, columnName));\n                    }\n                }\n                const columnFormulas = (modifier.options.columnFormulas || []);\n                for (let i = 0, iEnd = columnFormulas.length, columnFormula, formula; i < iEnd; ++i) {\n                    columnFormula = columnFormulas[i];\n                    formula = FormulaParser.parseFormula(columnFormula.formula, alternativeSeparators);\n                    modified.setColumn(columnFormula.column, modifier.processColumnFormula(formula, table, columnFormula.rowStart, columnFormula.rowEnd));\n                }\n                modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n                return table;\n            }\n            /**\n             * Process a column by replacing formula strings with calculated values.\n             *\n             * @private\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to extract column from and use as reference.\n             *\n             * @param {string} columnNameOrAlias\n             * Name or alias of column to process.\n             *\n             * @param {number} rowIndex\n             * Row index to start the replacing process from.\n             *\n             * @return {Highcharts.DataTableColumn}\n             * Returns the processed table column.\n             */\n            processColumn(table, columnNameOrAlias, rowIndex = 0) {\n                const alternativeSeparators = this.options.alternativeSeparators, column = (table.getColumn(columnNameOrAlias, true) || [])\n                    .slice(rowIndex > 0 ? rowIndex : 0);\n                for (let i = 0, iEnd = column.length, cacheFormula = [], cacheString = '', cell; i < iEnd; ++i) {\n                    cell = column[i];\n                    if (typeof cell === 'string' &&\n                        cell[0] === '=') {\n                        try {\n                            // use cache while formula string is repetitive\n                            cacheFormula = (cacheString === cell ?\n                                cacheFormula :\n                                FormulaParser.parseFormula(cell.substring(1), alternativeSeparators));\n                            // process parsed formula string\n                            column[i] =\n                                FormulaProcessor.processFormula(cacheFormula, table);\n                        }\n                        catch {\n                            column[i] = NaN;\n                        }\n                    }\n                }\n                return column;\n            }\n            /**\n             * Process a column by replacing cell values with calculated values from a\n             * given formula.\n             *\n             * @private\n             *\n             * @param {Highcharts.Formula} formula\n             * Formula to use for processing.\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to extract column from and use as reference.\n             *\n             * @param {number} rowStart\n             * Row index to start the replacing process from.\n             *\n             * @param {number} rowEnd\n             * Row index to end the replacing process.\n             *\n             * @return {Highcharts.DataTableColumn}\n             * Returns the processed table column.\n             */\n            processColumnFormula(formula, table, rowStart = 0, rowEnd = table.getRowCount()) {\n                rowStart = rowStart >= 0 ? rowStart : 0;\n                rowEnd = rowEnd >= 0 ? rowEnd : table.getRowCount() + rowEnd;\n                const column = [], modified = table.modified;\n                for (let i = 0, iEnd = (rowEnd - rowStart); i < iEnd; ++i) {\n                    try {\n                        column[i] = FormulaProcessor.processFormula(formula, modified);\n                    }\n                    catch {\n                        column[i] = NaN;\n                    }\n                    finally {\n                        formula = FormulaProcessor.translateReferences(formula, 0, 1);\n                    }\n                }\n                return column;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options of MathModifier.\n         * @private\n         */\n        MathModifier.defaultOptions = {\n            type: 'Math',\n            alternativeSeparators: false\n        };\n        DataModifier.registerType('Math', MathModifier);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MathModifier;\n    });\n    _registerModule(_modules, 'masters/modules/math-modifier.src.js', [_modules['Dashboards/Globals.js'], _modules['Data/Formula/Formula.js']], function (Globals, Formula) {\n\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        // Fill registries\n        /* *\n         *\n         *  Namespace\n         *\n         * */\n        const G = Globals;\n        G.Formula = Formula;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return G;\n    });\n}));"],"names":["factory","module","exports","define","amd","Dashboards","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","booleanRegExp","decimal1RegExp","decimal2RegExp","functionRegExp","operatorRegExp","rangeA1RegExp","rangeR1C1RegExp","referenceA1RegExp","referenceR1C1RegExp","extractParantheses","text","parantheseLevel","i","iEnd","length","char","parantheseStart","substring","error","Error","name","extractString","start","escaping","parseArgument","alternativeSeparators","match","beginColumnRelative","beginRowRelative","endColumnRelative","endRowRelative","range","type","beginColumn","parseInt","beginRow","endColumn","endRow","parseReferenceColumn","formula","parseFormula","decimalRegExp","next","trim","columnRelative","rowRelative","reference","column","row","push","parseFloat","string","parantheses","parseArguments","argumentsSeparator","term","paranteses","position","code","factor","charCodeAt","Math","pow","operators","isFormula","item","Array","isFunction","isOperator","indexOf","isRange","isReference","isValue","FormulaTypes","asLogicalStringRegExp","MAX_FALSE","Number","MAX_VALUE","MAX_STRING","MAX_TRUE","operatorPriority","processorFunctions","processorFunctionNameRegExp","asLogicalNumber","value","NaN","asLogicalString","toLowerCase","replace","asNumber","basicOperation","operator","x","y","result","round","getArgumentValue","arg","table","getRangeValues","processFunction","processFormula","columnNames","getColumnNames","slice","values","cell","cells","getColumn","j","jEnd","modified","getCell","getReferenceValue","columnName","operator2","formulaFunction","processor","getArgumentsValues","registerProcessorFunction","processorFunction","test","translateReferences","columnDelta","rowDelta","FormulaProcessor","ABS","abs","value2","AND","AVERAGE","count","isNaN","AVERAGEA","COUNT","COUNTA","IF","ISNA","MAX","NEGATIVE_INFINITY","isFinite","MEDIAN","median","half","floor","MIN","POSITIVE_INFINITY","MOD","value1","getModeMap","modeMap","MULT","keys","Object","modeKeys","modeCount","key","SNGL","modeKey","keyValue","NOT","OR","PRODUCT","calculated","SUM","XOR","lastValue","FormulaParser","FormulaType","DataModifier","MathModifier","constructor","options","defaultOptions","modifyTable","eventDetail","modifier","emit","formulaColumns","setColumn","processColumn","columnFormulas","columnFormula","processColumnFormula","rowStart","rowEnd","columnNameOrAlias","rowIndex","cacheFormula","cacheString","getRowCount","registerType","Globals","Formula","G"],"mappings":"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"}