{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Dashboards Math 3.5.0 (2025-07-14)\n *\n * (c) 2009-2025 Highsoft AS\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('dashboards/modules/math-modifier', ['dashboards'], function (Dashboards) {\n            factory(Dashboards);\n            factory.Dashboards = Dashboards;\n            return factory;\n        });\n    } else {\n        factory(typeof Dashboards !== 'undefined' ? Dashboards : undefined);\n    }\n}(function (Dashboards) {\n    'use strict';\n    var _modules = Dashboards ? Dashboards._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Dashboards.win.dispatchEvent(new CustomEvent(\n                    'DashboardsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Data/Formula/FormulaParser.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { isString } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * @private\n         */\n        const booleanRegExp = /^(?:FALSE|TRUE)/;\n        /**\n         * `.`-separated decimal.\n         * @private\n         */\n        const decimal1RegExp = /^[+\\-]?\\d+(?:\\.\\d+)?(?:e[+\\-]\\d+)?/;\n        /**\n         * `,`-separated decimal.\n         * @private\n         */\n        const decimal2RegExp = /^[+\\-]?\\d+(?:,\\d+)?(?:e[+\\-]\\d+)?/;\n        /**\n         * - Group 1: Function name\n         * @private\n         */\n        const functionRegExp = /^([A-Z][A-Z\\d\\.]*)\\(/;\n        /**\n         * @private\n         */\n        const operatorRegExp = /^(?:[+\\-*\\/^<=>]|<=|=>)/;\n        /**\n         * - Group 1: Start column\n         * - Group 2: Start row\n         * - Group 3: End column\n         * - Group 4: End row\n         * @private\n         */\n        const rangeA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)\\:(\\$?[A-Z]+)(\\$?\\d+)/;\n        /**\n         * - Group 1: Start row\n         * - Group 2: Start column\n         * - Group 3: End row\n         * - Group 4: End column\n         * @private\n         */\n        const rangeR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])\\:R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])/;\n        /**\n         * - Group 1: Column\n         * - Group 2: Row\n         * @private\n         */\n        const referenceA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)(?![\\:C])/;\n        /**\n         * - Group 1: Row\n         * - Group 2: Column\n         * @private\n         */\n        const referenceR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])(?!\\:)/;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Extracts the inner string of the most outer parantheses.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Text string to extract from.\n         *\n         * @return {string}\n         * Extracted parantheses. If not found an exception will be thrown.\n         */\n        function extractParantheses(text) {\n            let parantheseLevel = 0;\n            for (let i = 0, iEnd = text.length, char, parantheseStart = 1; i < iEnd; ++i) {\n                char = text[i];\n                if (char === '(') {\n                    if (!parantheseLevel) {\n                        parantheseStart = i + 1;\n                    }\n                    ++parantheseLevel;\n                    continue;\n                }\n                if (char === ')') {\n                    --parantheseLevel;\n                    if (!parantheseLevel) {\n                        return text.substring(parantheseStart, i);\n                    }\n                }\n            }\n            if (parantheseLevel > 0) {\n                const error = new Error('Incomplete parantheses.');\n                error.name = 'FormulaParseError';\n                throw error;\n            }\n            return '';\n        }\n        /**\n         * Extracts the inner string value.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Text string to extract from.\n         *\n         * @return {string}\n         * Extracted string. If not found an exception will be thrown.\n         */\n        function extractString(text) {\n            let start = -1;\n            for (let i = 0, iEnd = text.length, char, escaping = false; i < iEnd; ++i) {\n                char = text[i];\n                if (char === '\\\\') {\n                    escaping = !escaping;\n                    continue;\n                }\n                if (escaping) {\n                    escaping = false;\n                    continue;\n                }\n                if (char === '\"') {\n                    if (start < 0) {\n                        start = i;\n                    }\n                    else {\n                        return text.substring(start + 1, i); // `Ã¬` is excluding\n                    }\n                }\n            }\n            const error = new Error('Incomplete string.');\n            error.name = 'FormulaParseError';\n            throw error;\n        }\n        /**\n         * Parses an argument string. Formula arrays with a single term will be\n         * simplified to the term.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Argument string to parse.\n         *\n         * @param {boolean} alternativeSeparators\n         * Whether to expect `;` as argument separator and `,` as decimal separator.\n         *\n         * @return {Formula|Function|Range|Reference|Value}\n         * The recognized term structure.\n         */\n        function parseArgument(text, alternativeSeparators) {\n            let match;\n            // Check for a R1C1:R1C1 range notation\n            match = text.match(rangeR1C1RegExp);\n            if (match) {\n                const beginColumnRelative = (match[2] === '' || match[2][0] === '[');\n                const beginRowRelative = (match[1] === '' || match[1][0] === '[');\n                const endColumnRelative = (match[4] === '' || match[4][0] === '[');\n                const endRowRelative = (match[3] === '' || match[3][0] === '[');\n                const range = {\n                    type: 'range',\n                    beginColumn: (beginColumnRelative ?\n                        parseInt(match[2].substring(1, -1) || '0', 10) :\n                        parseInt(match[2], 10) - 1),\n                    beginRow: (beginRowRelative ?\n                        parseInt(match[1].substring(1, -1) || '0', 10) :\n                        parseInt(match[1], 10) - 1),\n                    endColumn: (endColumnRelative ?\n                        parseInt(match[4].substring(1, -1) || '0', 10) :\n                        parseInt(match[4], 10) - 1),\n                    endRow: (endRowRelative ?\n                        parseInt(match[3].substring(1, -1) || '0', 10) :\n                        parseInt(match[3], 10) - 1)\n                };\n                if (beginColumnRelative) {\n                    range.beginColumnRelative = true;\n                }\n                if (beginRowRelative) {\n                    range.beginRowRelative = true;\n                }\n                if (endColumnRelative) {\n                    range.endColumnRelative = true;\n                }\n                if (endRowRelative) {\n                    range.endRowRelative = true;\n                }\n                return range;\n            }\n            // Check for a A1:A1 range notation\n            match = text.match(rangeA1RegExp);\n            if (match) {\n                const beginColumnRelative = match[1][0] !== '$';\n                const beginRowRelative = match[2][0] !== '$';\n                const endColumnRelative = match[3][0] !== '$';\n                const endRowRelative = match[4][0] !== '$';\n                const range = {\n                    type: 'range',\n                    beginColumn: parseReferenceColumn(beginColumnRelative ?\n                        match[1] :\n                        match[1].substring(1)) - 1,\n                    beginRow: parseInt(beginRowRelative ?\n                        match[2] :\n                        match[2].substring(1), 10) - 1,\n                    endColumn: parseReferenceColumn(endColumnRelative ?\n                        match[3] :\n                        match[3].substring(1)) - 1,\n                    endRow: parseInt(endRowRelative ?\n                        match[4] :\n                        match[4].substring(1), 10) - 1\n                };\n                if (beginColumnRelative) {\n                    range.beginColumnRelative = true;\n                }\n                if (beginRowRelative) {\n                    range.beginRowRelative = true;\n                }\n                if (endColumnRelative) {\n                    range.endColumnRelative = true;\n                }\n                if (endRowRelative) {\n                    range.endRowRelative = true;\n                }\n                return range;\n            }\n            // Fallback to formula processing for other pattern types\n            const formula = parseFormula(text, alternativeSeparators);\n            return (formula.length === 1 && typeof formula[0] !== 'string' ?\n                formula[0] :\n                formula);\n        }\n        /**\n         * Parse arguments string inside function parantheses.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Parantheses string of the function.\n         *\n         * @param {boolean} alternativeSeparators\n         * Whether to expect `;` as argument separator and `,` as decimal separator.\n         *\n         * @return {Highcharts.FormulaArguments}\n         * Parsed arguments array.\n         */\n        function parseArguments(text, alternativeSeparators) {\n            const args = [], argumentsSeparator = (alternativeSeparators ? ';' : ',');\n            let parantheseLevel = 0, term = '';\n            for (let i = 0, iEnd = text.length, char; i < iEnd; ++i) {\n                char = text[i];\n                // Check for separator\n                if (char === argumentsSeparator &&\n                    !parantheseLevel &&\n                    term) {\n                    args.push(parseArgument(term, alternativeSeparators));\n                    term = '';\n                    // Check for a quoted string before skip logic\n                }\n                else if (char === '\"' &&\n                    !parantheseLevel &&\n                    !term) {\n                    const string = extractString(text.substring(i));\n                    args.push(string);\n                    i += string.length + 1; // Only +1 to cover ++i in for-loop\n                    // Skip space and check paranthesis nesting\n                }\n                else if (char !== ' ') {\n                    term += char;\n                    if (char === '(') {\n                        ++parantheseLevel;\n                    }\n                    else if (char === ')') {\n                        --parantheseLevel;\n                    }\n                }\n            }\n            // Look for left-overs from last argument\n            if (!parantheseLevel && term) {\n                args.push(parseArgument(term, alternativeSeparators));\n            }\n            return args;\n        }\n        /**\n         * Checks if there's one of the following operator before the negative number\n         * value: '*', '/' or '^'.\n         *\n         * Used to properly indicate a negative value reference or negate a directly\n         * passed number value.\n         */\n        function negativeReference(formula) {\n            const formulaLength = formula.length;\n            const priorFormula = formula[formulaLength - 2];\n            return (formula[formulaLength - 1] === '-' &&\n                isString(priorFormula) &&\n                !!priorFormula.match(/\\*|\\/|\\^/));\n        }\n        /**\n         * Converts a spreadsheet formula string into a formula array. Throws a\n         * `FormulaParserError` when the string can not be parsed.\n         *\n         * @private\n         * @function Formula.parseFormula\n         *\n         * @param {string} text\n         * Spreadsheet formula string, without the leading `=`.\n         *\n         * @param {boolean} alternativeSeparators\n         * * `false` to expect `,` between arguments and `.` in decimals.\n         * * `true` to expect `;` between arguments and `,` in decimals.\n         *\n         * @return {Formula.Formula}\n         * Formula array representing the string.\n         */\n        function parseFormula(text, alternativeSeparators) {\n            const decimalRegExp = (alternativeSeparators ?\n                decimal2RegExp :\n                decimal1RegExp), formula = [];\n            let match, next = (text[0] === '=' ? text.substring(1) : text).trim();\n            while (next) {\n                // Check for an R1C1 reference notation\n                match = next.match(referenceR1C1RegExp);\n                if (match) {\n                    const columnRelative = (match[2] === '' || match[2][0] === '[');\n                    const rowRelative = (match[1] === '' || match[1][0] === '[');\n                    const reference = {\n                        type: 'reference',\n                        column: (columnRelative ?\n                            parseInt(match[2].substring(1, -1) || '0', 10) :\n                            parseInt(match[2], 10) - 1),\n                        row: (rowRelative ?\n                            parseInt(match[1].substring(1, -1) || '0', 10) :\n                            parseInt(match[1], 10) - 1)\n                    };\n                    if (columnRelative) {\n                        reference.columnRelative = true;\n                    }\n                    if (rowRelative) {\n                        reference.rowRelative = true;\n                    }\n                    if (negativeReference(formula)) {\n                        formula.pop();\n                        reference.isNegative = true;\n                    }\n                    formula.push(reference);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for an A1 reference notation\n                match = next.match(referenceA1RegExp);\n                if (match) {\n                    const columnRelative = match[1][0] !== '$';\n                    const rowRelative = match[2][0] !== '$';\n                    const reference = {\n                        type: 'reference',\n                        column: parseReferenceColumn(columnRelative ?\n                            match[1] :\n                            match[1].substring(1)) - 1,\n                        row: parseInt(rowRelative ?\n                            match[2] :\n                            match[2].substring(1), 10) - 1\n                    };\n                    if (columnRelative) {\n                        reference.columnRelative = true;\n                    }\n                    if (rowRelative) {\n                        reference.rowRelative = true;\n                    }\n                    if (negativeReference(formula)) {\n                        formula.pop();\n                        reference.isNegative = true;\n                    }\n                    formula.push(reference);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a formula operator\n                match = next.match(operatorRegExp);\n                if (match) {\n                    formula.push(match[0]);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a boolean value\n                match = next.match(booleanRegExp);\n                if (match) {\n                    formula.push(match[0] === 'TRUE');\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a number value\n                match = next.match(decimalRegExp);\n                if (match) {\n                    let number = parseFloat(match[0]);\n                    // If the current value is multiplication-related and the previous\n                    // one is a minus sign, set the current value to negative and remove\n                    // the minus sign.\n                    if (negativeReference(formula)) {\n                        formula.pop();\n                        number = -number;\n                    }\n                    formula.push(number);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a quoted string\n                if (next[0] === '\"') {\n                    const string = extractString(next);\n                    formula.push(string.substring(1, -1));\n                    next = next.substring(string.length + 2).trim();\n                    continue;\n                }\n                // Check for a function\n                match = next.match(functionRegExp);\n                if (match) {\n                    next = next.substring(match[1].length).trim();\n                    const parantheses = extractParantheses(next);\n                    formula.push({\n                        type: 'function',\n                        name: match[1],\n                        args: parseArguments(parantheses, alternativeSeparators)\n                    });\n                    next = next.substring(parantheses.length + 2).trim();\n                    continue;\n                }\n                // Check for a formula in parantheses\n                if (next[0] === '(') {\n                    const paranteses = extractParantheses(next);\n                    if (paranteses) {\n                        formula\n                            .push(parseFormula(paranteses, alternativeSeparators));\n                        next = next.substring(paranteses.length + 2).trim();\n                        continue;\n                    }\n                }\n                // Something is not right\n                const position = text.length - next.length, error = new Error('Unexpected character `' +\n                    text.substring(position, position + 1) +\n                    '` at position ' + (position + 1) +\n                    '. (`...' + text.substring(position - 5, position + 6) + '...`)');\n                error.name = 'FormulaParseError';\n                throw error;\n            }\n            return formula;\n        }\n        /**\n         * Converts a reference column `A` of `A1` into a number. Supports endless sizes\n         * `ZZZ...`, just limited by integer precision.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Column string to convert.\n         *\n         * @return {number}\n         * Converted column index.\n         */\n        function parseReferenceColumn(text) {\n            let column = 0;\n            for (let i = 0, iEnd = text.length, code, factor = text.length - 1; i < iEnd; ++i) {\n                code = text.charCodeAt(i);\n                if (code >= 65 && code <= 90) {\n                    column += (code - 64) * Math.pow(26, factor);\n                }\n                --factor;\n            }\n            return column;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const FormulaParser = {\n            parseFormula\n        };\n\n        return FormulaParser;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/ABS.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `ABS(value)` implementation. Returns positive numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Array<number>}\n         * Result value of the process.\n         */\n        function ABS(args, table) {\n            const value = getArgumentValue(args[0], table);\n            switch (typeof value) {\n                case 'number':\n                    return Math.abs(value);\n                case 'object': {\n                    const values = [];\n                    for (let i = 0, iEnd = value.length, value2; i < iEnd; ++i) {\n                        value2 = value[i];\n                        if (typeof value2 !== 'number') {\n                            return NaN;\n                        }\n                        values.push(Math.abs(value2));\n                    }\n                    return values;\n                }\n                default:\n                    return NaN;\n            }\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('ABS', ABS);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ABS;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AND.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AND(...tests)` implementation. Returns `TRUE`, if all test\n         * results are not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function AND(args, table) {\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                if (!value ||\n                    (typeof value === 'object' &&\n                        !AND(value, table))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AND', AND);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AND;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AVERAGEA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AVERAGEA(...values)` implementation. Calculates the\n         * average of the given values. Strings and FALSE are calculated as 0.\n         *\n         * @private\n         * @function Formula.processorFunctions.AVERAGEA\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function AVERAGEA(args, table) {\n            let count = 0, result = 0;\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                switch (typeof value) {\n                    case 'boolean':\n                        ++count;\n                        result += (value ? 1 : 0);\n                        continue;\n                    case 'number':\n                        if (!isNaN(value)) {\n                            ++count;\n                            result += value;\n                        }\n                        continue;\n                    case 'string':\n                        ++count;\n                        continue;\n                    default:\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            switch (typeof value2) {\n                                case 'boolean':\n                                    ++count;\n                                    result += (value2 ? 1 : 0);\n                                    continue;\n                                case 'number':\n                                    if (!isNaN(value2)) {\n                                        ++count;\n                                        result += value2;\n                                    }\n                                    continue;\n                                case 'string':\n                                    ++count;\n                                    continue;\n                            }\n                        }\n                        continue;\n                }\n            }\n            return (count ? (result / count) : 0);\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AVERAGEA', AVERAGEA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AVERAGEA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/COUNTA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `COUNTA(...values)` implementation. Returns the count of\n         * given values that are not empty.\n         *\n         * @private\n         * @function Formula.processorFunctions.COUNT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function COUNTA(args, table) {\n            const values = FormulaProcessor.getArgumentsValues(args, table);\n            let count = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (isNaN(value)) {\n                            continue;\n                        }\n                        break;\n                    case 'object':\n                        count += COUNTA(value, table);\n                        continue;\n                    case 'string':\n                        if (!value) {\n                            continue;\n                        }\n                        break;\n                }\n                ++count;\n            }\n            return count;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('COUNTA', COUNTA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return COUNTA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/IF.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `IF(test, value1, value2)` implementation. Returns one of\n         * the values based on the test result. `value1` will be returned, if the test\n         * result is not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.IF\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n         * Result value of the process.\n         */\n        function IF(args, table) {\n            return (getArgumentValue(args[0], table) ?\n                getArgumentValue(args[1], table) :\n                getArgumentValue(args[2], table));\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('IF', IF);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return IF;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/ISNA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `ISNA(value)` implementation. Returns TRUE if value is not\n         * a number.\n         *\n         * @private\n         * @function Formula.processorFunctions.ISNA\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function ISNA(args, table) {\n            const value = getArgumentValue(args[0], table);\n            return (typeof value !== 'number' || isNaN(value));\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('ISNA', ISNA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ISNA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MOD.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MOD(value1, value2)` implementation. Calculates the rest\n         * of the division with the given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MOD\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MOD(args, table) {\n            let value1 = getArgumentValue(args[0], table), value2 = getArgumentValue(args[1], table);\n            if (typeof value1 === 'object') {\n                value1 = value1[0];\n            }\n            if (typeof value2 === 'object') {\n                value2 = value2[0];\n            }\n            if (typeof value1 !== 'number' ||\n                typeof value2 !== 'number' ||\n                value2 === 0) {\n                return NaN;\n            }\n            return value1 % value2;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MOD', MOD);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MOD;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MODE.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates the mode map of the given arguments.\n         *\n         * @private\n         * @function Formula.processorFunctions.MULT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function getModeMap(args, table) {\n            const modeMap = {}, values = FormulaProcessor.getArgumentsValues(args, table);\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            modeMap[value] = (modeMap[value] || 0) + 1;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            if (typeof value2 === 'number' &&\n                                !isNaN(value2)) {\n                                modeMap[value2] = (modeMap[value2] || 0) + 1;\n                            }\n                        }\n                        break;\n                }\n            }\n            return modeMap;\n        }\n        /**\n         * Processor for the `MODE.MULT(...values)` implementation. Calculates the most\n         * frequent values of the give values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MULT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number|Array<number>}\n         * Result value of the process.\n         */\n        function MULT(args, table) {\n            const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n            if (!keys.length) {\n                return NaN;\n            }\n            let modeKeys = [parseFloat(keys[0])], modeCount = modeMap[keys[0]];\n            for (let i = 1, iEnd = keys.length, key, count; i < iEnd; ++i) {\n                key = keys[i];\n                count = modeMap[key];\n                if (modeCount < count) {\n                    modeKeys = [parseFloat(key)];\n                    modeCount = count;\n                }\n                else if (modeCount === count) {\n                    modeKeys.push(parseFloat(key));\n                }\n            }\n            return modeCount > 1 ? modeKeys : NaN;\n        }\n        /**\n         * Processor for the `MODE.SNGL(...values)` implementation. Calculates the\n         * lowest most frequent value of the give values.\n         *\n         * @private\n         * @function Formula.processorFunctions['MODE.SNGL']\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function SNGL(args, table) {\n            const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n            if (!keys.length) {\n                return NaN;\n            }\n            let modeKey = parseFloat(keys[0]), modeCount = modeMap[keys[0]];\n            for (let i = 1, iEnd = keys.length, key, keyValue, count; i < iEnd; ++i) {\n                key = keys[i];\n                count = modeMap[key];\n                if (modeCount < count) {\n                    modeKey = parseFloat(key);\n                    modeCount = count;\n                }\n                else if (modeCount === count) {\n                    keyValue = parseFloat(key);\n                    if (modeKey > keyValue) {\n                        modeKey = keyValue;\n                        modeCount = count;\n                    }\n                }\n            }\n            return modeCount > 1 ? modeKey : NaN;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MODE', SNGL);\n        FormulaProcessor.registerProcessorFunction('MODE.MULT', MULT);\n        FormulaProcessor.registerProcessorFunction('MODE.SNGL', SNGL);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MODE = {\n            MULT,\n            SNGL\n        };\n\n        return MODE;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/NOT.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `NOT(value)` implementation. Returns the opposite test\n         * result.\n         *\n         * @private\n         * @function Formula.processorFunctions.NOT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean|number}\n         * Result value of the process.\n         */\n        function NOT(args, table) {\n            let value = getArgumentValue(args[0], table);\n            if (typeof value === 'object') {\n                value = value[0];\n            }\n            switch (typeof value) {\n                case 'boolean':\n                case 'number':\n                    return !value;\n            }\n            return NaN;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('NOT', NOT);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return NOT;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/OR.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `OR(...tests)` implementation. Returns `TRUE`, if one test\n         * result is not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function OR(args, table) {\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                if (typeof value === 'object') {\n                    if (OR(value, table)) {\n                        return true;\n                    }\n                }\n                else if (value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('OR', OR);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return OR;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/XOR.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `XOR(...tests)` implementation. Returns `TRUE`, if at least\n         * one of the given tests differs in result of other tests.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean|number}\n         * Result value of the process.\n         */\n        function XOR(args, table) {\n            for (let i = 0, iEnd = args.length, lastValue, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                switch (typeof value) {\n                    case 'boolean':\n                    case 'number':\n                        if (typeof lastValue === 'undefined') {\n                            lastValue = !!value;\n                        }\n                        else if (!!value !== lastValue) {\n                            return true;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            switch (typeof value2) {\n                                case 'boolean':\n                                case 'number':\n                                    if (typeof lastValue === 'undefined') {\n                                        lastValue = !!value2;\n                                    }\n                                    else if (!!value2 !== lastValue) {\n                                        return true;\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                }\n            }\n            return false;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('XOR', XOR);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return XOR;\n    });\n    _registerModule(_modules, 'Data/Formula/Formula.js', [_modules['Data/Formula/FormulaParser.js'], _modules['Data/Formula/FormulaProcessor.js'], _modules['Data/Formula/FormulaTypes.js']], function (FormulaParser, FormulaProcessor, FormulaType) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /**\n         * Formula engine to make use of spreadsheet formula strings.\n         * @internal\n         */\n        const Formula = {\n            ...FormulaParser,\n            ...FormulaProcessor,\n            ...FormulaType\n        };\n\n        return Formula;\n    });\n    _registerModule(_modules, 'Data/Modifiers/MathModifier.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Data/Formula/FormulaParser.js'], _modules['Data/Formula/FormulaProcessor.js']], function (DataModifier, FormulaParser, FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2025 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Replaces formula strings in a table with calculated values.\n         *\n         * @class\n         * @name Highcharts.DataModifier.types.MathModifier\n         * @augments Highcharts.DataModifier\n         */\n        class MathModifier extends DataModifier {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(options) {\n                super();\n                this.options = {\n                    ...MathModifier.defaultOptions,\n                    ...options\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            modifyTable(table, eventDetail) {\n                const modifier = this;\n                modifier.emit({ type: 'modify', detail: eventDetail, table });\n                const alternativeSeparators = modifier.options.alternativeSeparators, formulaColumns = (modifier.options.formulaColumns ||\n                    table.getColumnNames()), modified = table.modified;\n                for (let i = 0, iEnd = formulaColumns.length, columnName; i < iEnd; ++i) {\n                    columnName = formulaColumns[i];\n                    if (formulaColumns.indexOf(columnName) >= 0) {\n                        modified.setColumn(columnName, modifier.processColumn(table, columnName));\n                    }\n                }\n                const columnFormulas = (modifier.options.columnFormulas || []);\n                for (let i = 0, iEnd = columnFormulas.length, columnFormula, formula; i < iEnd; ++i) {\n                    columnFormula = columnFormulas[i];\n                    formula = FormulaParser.parseFormula(columnFormula.formula, alternativeSeparators);\n                    modified.setColumn(columnFormula.column, modifier.processColumnFormula(formula, table, columnFormula.rowStart, columnFormula.rowEnd));\n                }\n                modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n                return table;\n            }\n            /**\n             * Process a column by replacing formula strings with calculated values.\n             *\n             * @private\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to extract column from and use as reference.\n             *\n             * @param {string} columnName\n             * Name of column to process.\n             *\n             * @param {number} rowIndex\n             * Row index to start the replacing process from.\n             *\n             * @return {Highcharts.DataTableColumn}\n             * Returns the processed table column.\n             */\n            processColumn(table, columnName, rowIndex = 0) {\n                const alternativeSeparators = this.options.alternativeSeparators, column = (table.getColumn(columnName, true) || [])\n                    .slice(rowIndex > 0 ? rowIndex : 0);\n                for (let i = 0, iEnd = column.length, cacheFormula = [], cacheString = '', cell; i < iEnd; ++i) {\n                    cell = column[i];\n                    if (typeof cell === 'string' &&\n                        cell[0] === '=') {\n                        try {\n                            // Use cache while formula string is repetitive\n                            cacheFormula = (cacheString === cell ?\n                                cacheFormula :\n                                FormulaParser.parseFormula(cell.substring(1), alternativeSeparators));\n                            // Process parsed formula string\n                            column[i] =\n                                FormulaProcessor.processFormula(cacheFormula, table);\n                        }\n                        catch {\n                            column[i] = NaN;\n                        }\n                    }\n                }\n                return column;\n            }\n            /**\n             * Process a column by replacing cell values with calculated values from a\n             * given formula.\n             *\n             * @private\n             *\n             * @param {Highcharts.Formula} formula\n             * Formula to use for processing.\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to extract column from and use as reference.\n             *\n             * @param {number} rowStart\n             * Row index to start the replacing process from.\n             *\n             * @param {number} rowEnd\n             * Row index to end the replacing process.\n             *\n             * @return {Highcharts.DataTableColumn}\n             * Returns the processed table column.\n             */\n            processColumnFormula(formula, table, rowStart = 0, rowEnd = table.getRowCount()) {\n                rowStart = rowStart >= 0 ? rowStart : 0;\n                rowEnd = rowEnd >= 0 ? rowEnd : table.getRowCount() + rowEnd;\n                const column = [], modified = table.modified;\n                for (let i = 0, iEnd = (rowEnd - rowStart); i < iEnd; ++i) {\n                    try {\n                        column[i] = FormulaProcessor.processFormula(formula, modified);\n                    }\n                    catch {\n                        column[i] = NaN;\n                    }\n                    finally {\n                        formula = FormulaProcessor.translateReferences(formula, 0, 1);\n                    }\n                }\n                return column;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options of MathModifier.\n         * @private\n         */\n        MathModifier.defaultOptions = {\n            type: 'Math',\n            alternativeSeparators: false\n        };\n        DataModifier.registerType('Math', MathModifier);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MathModifier;\n    });\n    _registerModule(_modules, 'masters/modules/math-modifier.js', [_modules['Dashboards/Globals.js'], _modules['Data/Formula/Formula.js']], function (Globals, Formula) {\n\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        // Fill registries\n        /* *\n         *\n         *  Namespace\n         *\n         * */\n        const G = Globals;\n        G.Formula = Formula;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return G;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Dashboards","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","U","isString","booleanRegExp","decimal1RegExp","decimal2RegExp","functionRegExp","operatorRegExp","rangeA1RegExp","rangeR1C1RegExp","referenceA1RegExp","referenceR1C1RegExp","extractParantheses","text","parantheseLevel","i","iEnd","length","char","parantheseStart","substring","error","Error","name","extractString","start","escaping","parseArgument","alternativeSeparators","match","beginColumnRelative","beginRowRelative","endColumnRelative","endRowRelative","range","type","beginColumn","parseInt","beginRow","endColumn","endRow","parseReferenceColumn","formula","parseFormula","negativeReference","formulaLength","priorFormula","decimalRegExp","next","trim","columnRelative","rowRelative","reference","column","row","pop","isNegative","push","number","parseFloat","string","parantheses","parseArguments","argumentsSeparator","term","paranteses","position","code","factor","charCodeAt","Math","pow","FormulaProcessor","getArgumentValue","ABS","table","value","abs","values","value2","NaN","registerProcessorFunction","AND","AVERAGEA","count","result","isNaN","j","jEnd","COUNTA","getArgumentsValues","IF","ISNA","MOD","value1","getModeMap","modeMap","MULT","keys","Object","modeKeys","modeCount","key","SNGL","modeKey","keyValue","NOT","OR","XOR","lastValue","FormulaParser","FormulaType","DataModifier","MathModifier","constructor","options","defaultOptions","modifyTable","eventDetail","modifier","emit","formulaColumns","getColumnNames","modified","columnName","indexOf","setColumn","processColumn","columnFormulas","columnFormula","processColumnFormula","rowStart","rowEnd","rowIndex","getColumn","slice","cacheFormula","cell","cacheString","processFormula","getRowCount","translateReferences","registerType","Globals","Formula","G"],"mappings":"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"}