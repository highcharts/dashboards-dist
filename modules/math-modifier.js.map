{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts Dashboards Math 3.2.0 (2025-03-26)\n *\n * (c) 2009-2024 Highsoft AS\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('dashboards/modules/math-modifier', ['dashboards'], function (Dashboards) {\n            factory(Dashboards);\n            factory.Dashboards = Dashboards;\n            return factory;\n        });\n    } else {\n        factory(typeof Dashboards !== 'undefined' ? Dashboards : undefined);\n    }\n}(function (Dashboards) {\n    'use strict';\n    var _modules = Dashboards ? Dashboards._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Dashboards.win.dispatchEvent(new CustomEvent(\n                    'DashboardsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Data/Formula/FormulaParser.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * @private\n         */\n        const booleanRegExp = /^(?:FALSE|TRUE)/;\n        /**\n         * `.`-separated decimal.\n         * @private\n         */\n        const decimal1RegExp = /^[+\\-]?\\d+(?:\\.\\d+)?(?:e[+\\-]\\d+)?/;\n        /**\n         * `,`-separated decimal.\n         * @private\n         */\n        const decimal2RegExp = /^[+\\-]?\\d+(?:,\\d+)?(?:e[+\\-]\\d+)?/;\n        /**\n         * - Group 1: Function name\n         * @private\n         */\n        const functionRegExp = /^([A-Z][A-Z\\d\\.]*)\\(/;\n        /**\n         * @private\n         */\n        const operatorRegExp = /^(?:[+\\-*\\/^<=>]|<=|=>)/;\n        /**\n         * - Group 1: Start column\n         * - Group 2: Start row\n         * - Group 3: End column\n         * - Group 4: End row\n         * @private\n         */\n        const rangeA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)\\:(\\$?[A-Z]+)(\\$?\\d+)/;\n        /**\n         * - Group 1: Start row\n         * - Group 2: Start column\n         * - Group 3: End row\n         * - Group 4: End column\n         * @private\n         */\n        const rangeR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])\\:R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])/;\n        /**\n         * - Group 1: Column\n         * - Group 2: Row\n         * @private\n         */\n        const referenceA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)(?![\\:C])/;\n        /**\n         * - Group 1: Row\n         * - Group 2: Column\n         * @private\n         */\n        const referenceR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])(?!\\:)/;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Extracts the inner string of the most outer parantheses.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Text string to extract from.\n         *\n         * @return {string}\n         * Extracted parantheses. If not found an exception will be thrown.\n         */\n        function extractParantheses(text) {\n            let parantheseLevel = 0;\n            for (let i = 0, iEnd = text.length, char, parantheseStart = 1; i < iEnd; ++i) {\n                char = text[i];\n                if (char === '(') {\n                    if (!parantheseLevel) {\n                        parantheseStart = i + 1;\n                    }\n                    ++parantheseLevel;\n                    continue;\n                }\n                if (char === ')') {\n                    --parantheseLevel;\n                    if (!parantheseLevel) {\n                        return text.substring(parantheseStart, i);\n                    }\n                }\n            }\n            if (parantheseLevel > 0) {\n                const error = new Error('Incomplete parantheses.');\n                error.name = 'FormulaParseError';\n                throw error;\n            }\n            return '';\n        }\n        /**\n         * Extracts the inner string value.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Text string to extract from.\n         *\n         * @return {string}\n         * Extracted string. If not found an exception will be thrown.\n         */\n        function extractString(text) {\n            let start = -1;\n            for (let i = 0, iEnd = text.length, char, escaping = false; i < iEnd; ++i) {\n                char = text[i];\n                if (char === '\\\\') {\n                    escaping = !escaping;\n                    continue;\n                }\n                if (escaping) {\n                    escaping = false;\n                    continue;\n                }\n                if (char === '\"') {\n                    if (start < 0) {\n                        start = i;\n                    }\n                    else {\n                        return text.substring(start + 1, i); // `Ã¬` is excluding\n                    }\n                }\n            }\n            const error = new Error('Incomplete string.');\n            error.name = 'FormulaParseError';\n            throw error;\n        }\n        /**\n         * Parses an argument string. Formula arrays with a single term will be\n         * simplified to the term.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Argument string to parse.\n         *\n         * @param {boolean} alternativeSeparators\n         * Whether to expect `;` as argument separator and `,` as decimal separator.\n         *\n         * @return {Formula|Function|Range|Reference|Value}\n         * The recognized term structure.\n         */\n        function parseArgument(text, alternativeSeparators) {\n            let match;\n            // Check for a R1C1:R1C1 range notation\n            match = text.match(rangeR1C1RegExp);\n            if (match) {\n                const beginColumnRelative = (match[2] === '' || match[2][0] === '[');\n                const beginRowRelative = (match[1] === '' || match[1][0] === '[');\n                const endColumnRelative = (match[4] === '' || match[4][0] === '[');\n                const endRowRelative = (match[3] === '' || match[3][0] === '[');\n                const range = {\n                    type: 'range',\n                    beginColumn: (beginColumnRelative ?\n                        parseInt(match[2].substring(1, -1) || '0', 10) :\n                        parseInt(match[2], 10) - 1),\n                    beginRow: (beginRowRelative ?\n                        parseInt(match[1].substring(1, -1) || '0', 10) :\n                        parseInt(match[1], 10) - 1),\n                    endColumn: (endColumnRelative ?\n                        parseInt(match[4].substring(1, -1) || '0', 10) :\n                        parseInt(match[4], 10) - 1),\n                    endRow: (endRowRelative ?\n                        parseInt(match[3].substring(1, -1) || '0', 10) :\n                        parseInt(match[3], 10) - 1)\n                };\n                if (beginColumnRelative) {\n                    range.beginColumnRelative = true;\n                }\n                if (beginRowRelative) {\n                    range.beginRowRelative = true;\n                }\n                if (endColumnRelative) {\n                    range.endColumnRelative = true;\n                }\n                if (endRowRelative) {\n                    range.endRowRelative = true;\n                }\n                return range;\n            }\n            // Check for a A1:A1 range notation\n            match = text.match(rangeA1RegExp);\n            if (match) {\n                const beginColumnRelative = match[1][0] !== '$';\n                const beginRowRelative = match[2][0] !== '$';\n                const endColumnRelative = match[3][0] !== '$';\n                const endRowRelative = match[4][0] !== '$';\n                const range = {\n                    type: 'range',\n                    beginColumn: parseReferenceColumn(beginColumnRelative ?\n                        match[1] :\n                        match[1].substring(1)) - 1,\n                    beginRow: parseInt(beginRowRelative ?\n                        match[2] :\n                        match[2].substring(1), 10) - 1,\n                    endColumn: parseReferenceColumn(endColumnRelative ?\n                        match[3] :\n                        match[3].substring(1)) - 1,\n                    endRow: parseInt(endRowRelative ?\n                        match[4] :\n                        match[4].substring(1), 10) - 1\n                };\n                if (beginColumnRelative) {\n                    range.beginColumnRelative = true;\n                }\n                if (beginRowRelative) {\n                    range.beginRowRelative = true;\n                }\n                if (endColumnRelative) {\n                    range.endColumnRelative = true;\n                }\n                if (endRowRelative) {\n                    range.endRowRelative = true;\n                }\n                return range;\n            }\n            // Fallback to formula processing for other pattern types\n            const formula = parseFormula(text, alternativeSeparators);\n            return (formula.length === 1 && typeof formula[0] !== 'string' ?\n                formula[0] :\n                formula);\n        }\n        /**\n         * Parse arguments string inside function parantheses.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Parantheses string of the function.\n         *\n         * @param {boolean} alternativeSeparators\n         * Whether to expect `;` as argument separator and `,` as decimal separator.\n         *\n         * @return {Highcharts.FormulaArguments}\n         * Parsed arguments array.\n         */\n        function parseArguments(text, alternativeSeparators) {\n            const args = [], argumentsSeparator = (alternativeSeparators ? ';' : ',');\n            let parantheseLevel = 0, term = '';\n            for (let i = 0, iEnd = text.length, char; i < iEnd; ++i) {\n                char = text[i];\n                // Check for separator\n                if (char === argumentsSeparator &&\n                    !parantheseLevel &&\n                    term) {\n                    args.push(parseArgument(term, alternativeSeparators));\n                    term = '';\n                    // Check for a quoted string before skip logic\n                }\n                else if (char === '\"' &&\n                    !parantheseLevel &&\n                    !term) {\n                    const string = extractString(text.substring(i));\n                    args.push(string);\n                    i += string.length + 1; // Only +1 to cover ++i in for-loop\n                    // Skip space and check paranthesis nesting\n                }\n                else if (char !== ' ') {\n                    term += char;\n                    if (char === '(') {\n                        ++parantheseLevel;\n                    }\n                    else if (char === ')') {\n                        --parantheseLevel;\n                    }\n                }\n            }\n            // Look for left-overs from last argument\n            if (!parantheseLevel && term) {\n                args.push(parseArgument(term, alternativeSeparators));\n            }\n            return args;\n        }\n        /**\n         * Converts a spreadsheet formula string into a formula array. Throws a\n         * `FormulaParserError` when the string can not be parsed.\n         *\n         * @private\n         * @function Formula.parseFormula\n         *\n         * @param {string} text\n         * Spreadsheet formula string, without the leading `=`.\n         *\n         * @param {boolean} alternativeSeparators\n         * * `false` to expect `,` between arguments and `.` in decimals.\n         * * `true` to expect `;` between arguments and `,` in decimals.\n         *\n         * @return {Formula.Formula}\n         * Formula array representing the string.\n         */\n        function parseFormula(text, alternativeSeparators) {\n            const decimalRegExp = (alternativeSeparators ?\n                decimal2RegExp :\n                decimal1RegExp), formula = [];\n            let match, next = (text[0] === '=' ? text.substring(1) : text).trim();\n            while (next) {\n                // Check for an R1C1 reference notation\n                match = next.match(referenceR1C1RegExp);\n                if (match) {\n                    const columnRelative = (match[2] === '' || match[2][0] === '[');\n                    const rowRelative = (match[1] === '' || match[1][0] === '[');\n                    const reference = {\n                        type: 'reference',\n                        column: (columnRelative ?\n                            parseInt(match[2].substring(1, -1) || '0', 10) :\n                            parseInt(match[2], 10) - 1),\n                        row: (rowRelative ?\n                            parseInt(match[1].substring(1, -1) || '0', 10) :\n                            parseInt(match[1], 10) - 1)\n                    };\n                    if (columnRelative) {\n                        reference.columnRelative = true;\n                    }\n                    if (rowRelative) {\n                        reference.rowRelative = true;\n                    }\n                    formula.push(reference);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for an A1 reference notation\n                match = next.match(referenceA1RegExp);\n                if (match) {\n                    const columnRelative = match[1][0] !== '$';\n                    const rowRelative = match[2][0] !== '$';\n                    const reference = {\n                        type: 'reference',\n                        column: parseReferenceColumn(columnRelative ?\n                            match[1] :\n                            match[1].substring(1)) - 1,\n                        row: parseInt(rowRelative ?\n                            match[2] :\n                            match[2].substring(1), 10) - 1\n                    };\n                    if (columnRelative) {\n                        reference.columnRelative = true;\n                    }\n                    if (rowRelative) {\n                        reference.rowRelative = true;\n                    }\n                    formula.push(reference);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a formula operator\n                match = next.match(operatorRegExp);\n                if (match) {\n                    formula.push(match[0]);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a boolean value\n                match = next.match(booleanRegExp);\n                if (match) {\n                    formula.push(match[0] === 'TRUE');\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a number value\n                match = next.match(decimalRegExp);\n                if (match) {\n                    formula.push(parseFloat(match[0]));\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a quoted string\n                if (next[0] === '\"') {\n                    const string = extractString(next);\n                    formula.push(string.substring(1, -1));\n                    next = next.substring(string.length + 2).trim();\n                    continue;\n                }\n                // Check for a function\n                match = next.match(functionRegExp);\n                if (match) {\n                    next = next.substring(match[1].length).trim();\n                    const parantheses = extractParantheses(next);\n                    formula.push({\n                        type: 'function',\n                        name: match[1],\n                        args: parseArguments(parantheses, alternativeSeparators)\n                    });\n                    next = next.substring(parantheses.length + 2).trim();\n                    continue;\n                }\n                // Check for a formula in parantheses\n                if (next[0] === '(') {\n                    const paranteses = extractParantheses(next);\n                    if (paranteses) {\n                        formula\n                            .push(parseFormula(paranteses, alternativeSeparators));\n                        next = next.substring(paranteses.length + 2).trim();\n                        continue;\n                    }\n                }\n                // Something is not right\n                const position = text.length - next.length, error = new Error('Unexpected character `' +\n                    text.substring(position, position + 1) +\n                    '` at position ' + (position + 1) +\n                    '. (`...' + text.substring(position - 5, position + 6) + '...`)');\n                error.name = 'FormulaParseError';\n                throw error;\n            }\n            return formula;\n        }\n        /**\n         * Converts a reference column `A` of `A1` into a number. Supports endless sizes\n         * `ZZZ...`, just limited by integer precision.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Column string to convert.\n         *\n         * @return {number}\n         * Converted column index.\n         */\n        function parseReferenceColumn(text) {\n            let column = 0;\n            for (let i = 0, iEnd = text.length, code, factor = text.length - 1; i < iEnd; ++i) {\n                code = text.charCodeAt(i);\n                if (code >= 65 && code <= 90) {\n                    column += (code - 64) * Math.pow(26, factor);\n                }\n                --factor;\n            }\n            return column;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const FormulaParser = {\n            parseFormula\n        };\n\n        return FormulaParser;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/ABS.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `ABS(value)` implementation. Returns positive numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Array<number>}\n         * Result value of the process.\n         */\n        function ABS(args, table) {\n            const value = getArgumentValue(args[0], table);\n            switch (typeof value) {\n                case 'number':\n                    return Math.abs(value);\n                case 'object': {\n                    const values = [];\n                    for (let i = 0, iEnd = value.length, value2; i < iEnd; ++i) {\n                        value2 = value[i];\n                        if (typeof value2 !== 'number') {\n                            return NaN;\n                        }\n                        values.push(Math.abs(value2));\n                    }\n                    return values;\n                }\n                default:\n                    return NaN;\n            }\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('ABS', ABS);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ABS;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AND.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AND(...tests)` implementation. Returns `TRUE`, if all test\n         * results are not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function AND(args, table) {\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                if (!value ||\n                    (typeof value === 'object' &&\n                        !AND(value, table))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AND', AND);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AND;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AVERAGEA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AVERAGEA(...values)` implementation. Calculates the\n         * average of the given values. Strings and FALSE are calculated as 0.\n         *\n         * @private\n         * @function Formula.processorFunctions.AVERAGEA\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function AVERAGEA(args, table) {\n            let count = 0, result = 0;\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                switch (typeof value) {\n                    case 'boolean':\n                        ++count;\n                        result += (value ? 1 : 0);\n                        continue;\n                    case 'number':\n                        if (!isNaN(value)) {\n                            ++count;\n                            result += value;\n                        }\n                        continue;\n                    case 'string':\n                        ++count;\n                        continue;\n                    default:\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            switch (typeof value2) {\n                                case 'boolean':\n                                    ++count;\n                                    result += (value2 ? 1 : 0);\n                                    continue;\n                                case 'number':\n                                    if (!isNaN(value2)) {\n                                        ++count;\n                                        result += value2;\n                                    }\n                                    continue;\n                                case 'string':\n                                    ++count;\n                                    continue;\n                            }\n                        }\n                        continue;\n                }\n            }\n            return (count ? (result / count) : 0);\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AVERAGEA', AVERAGEA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AVERAGEA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/COUNTA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `COUNTA(...values)` implementation. Returns the count of\n         * given values that are not empty.\n         *\n         * @private\n         * @function Formula.processorFunctions.COUNT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function COUNTA(args, table) {\n            const values = FormulaProcessor.getArgumentsValues(args, table);\n            let count = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (isNaN(value)) {\n                            continue;\n                        }\n                        break;\n                    case 'object':\n                        count += COUNTA(value, table);\n                        continue;\n                    case 'string':\n                        if (!value) {\n                            continue;\n                        }\n                        break;\n                }\n                ++count;\n            }\n            return count;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('COUNTA', COUNTA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return COUNTA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/IF.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `IF(test, value1, value2)` implementation. Returns one of\n         * the values based on the test result. `value1` will be returned, if the test\n         * result is not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.IF\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n         * Result value of the process.\n         */\n        function IF(args, table) {\n            return (getArgumentValue(args[0], table) ?\n                getArgumentValue(args[1], table) :\n                getArgumentValue(args[2], table));\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('IF', IF);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return IF;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/ISNA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `ISNA(value)` implementation. Returns TRUE if value is not\n         * a number.\n         *\n         * @private\n         * @function Formula.processorFunctions.ISNA\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function ISNA(args, table) {\n            const value = getArgumentValue(args[0], table);\n            return (typeof value !== 'number' || isNaN(value));\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('ISNA', ISNA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ISNA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MOD.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MOD(value1, value2)` implementation. Calculates the rest\n         * of the division with the given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MOD\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MOD(args, table) {\n            let value1 = getArgumentValue(args[0], table), value2 = getArgumentValue(args[1], table);\n            if (typeof value1 === 'object') {\n                value1 = value1[0];\n            }\n            if (typeof value2 === 'object') {\n                value2 = value2[0];\n            }\n            if (typeof value1 !== 'number' ||\n                typeof value2 !== 'number' ||\n                value2 === 0) {\n                return NaN;\n            }\n            return value1 % value2;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MOD', MOD);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MOD;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MODE.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates the mode map of the given arguments.\n         *\n         * @private\n         * @function Formula.processorFunctions.MULT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function getModeMap(args, table) {\n            const modeMap = {}, values = FormulaProcessor.getArgumentsValues(args, table);\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            modeMap[value] = (modeMap[value] || 0) + 1;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            if (typeof value2 === 'number' &&\n                                !isNaN(value2)) {\n                                modeMap[value2] = (modeMap[value2] || 0) + 1;\n                            }\n                        }\n                        break;\n                }\n            }\n            return modeMap;\n        }\n        /**\n         * Processor for the `MODE.MULT(...values)` implementation. Calculates the most\n         * frequent values of the give values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MULT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number|Array<number>}\n         * Result value of the process.\n         */\n        function MULT(args, table) {\n            const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n            if (!keys.length) {\n                return NaN;\n            }\n            let modeKeys = [parseFloat(keys[0])], modeCount = modeMap[keys[0]];\n            for (let i = 1, iEnd = keys.length, key, count; i < iEnd; ++i) {\n                key = keys[i];\n                count = modeMap[key];\n                if (modeCount < count) {\n                    modeKeys = [parseFloat(key)];\n                    modeCount = count;\n                }\n                else if (modeCount === count) {\n                    modeKeys.push(parseFloat(key));\n                }\n            }\n            return modeCount > 1 ? modeKeys : NaN;\n        }\n        /**\n         * Processor for the `MODE.SNGL(...values)` implementation. Calculates the\n         * lowest most frequent value of the give values.\n         *\n         * @private\n         * @function Formula.processorFunctions['MODE.SNGL']\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function SNGL(args, table) {\n            const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n            if (!keys.length) {\n                return NaN;\n            }\n            let modeKey = parseFloat(keys[0]), modeCount = modeMap[keys[0]];\n            for (let i = 1, iEnd = keys.length, key, keyValue, count; i < iEnd; ++i) {\n                key = keys[i];\n                count = modeMap[key];\n                if (modeCount < count) {\n                    modeKey = parseFloat(key);\n                    modeCount = count;\n                }\n                else if (modeCount === count) {\n                    keyValue = parseFloat(key);\n                    if (modeKey > keyValue) {\n                        modeKey = keyValue;\n                        modeCount = count;\n                    }\n                }\n            }\n            return modeCount > 1 ? modeKey : NaN;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MODE', SNGL);\n        FormulaProcessor.registerProcessorFunction('MODE.MULT', MULT);\n        FormulaProcessor.registerProcessorFunction('MODE.SNGL', SNGL);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MODE = {\n            MULT,\n            SNGL\n        };\n\n        return MODE;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/NOT.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `NOT(value)` implementation. Returns the opposite test\n         * result.\n         *\n         * @private\n         * @function Formula.processorFunctions.NOT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean|number}\n         * Result value of the process.\n         */\n        function NOT(args, table) {\n            let value = getArgumentValue(args[0], table);\n            if (typeof value === 'object') {\n                value = value[0];\n            }\n            switch (typeof value) {\n                case 'boolean':\n                case 'number':\n                    return !value;\n            }\n            return NaN;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('NOT', NOT);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return NOT;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/OR.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `OR(...tests)` implementation. Returns `TRUE`, if one test\n         * result is not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function OR(args, table) {\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                if (typeof value === 'object') {\n                    if (OR(value, table)) {\n                        return true;\n                    }\n                }\n                else if (value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('OR', OR);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return OR;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/XOR.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `XOR(...tests)` implementation. Returns `TRUE`, if at least\n         * one of the given tests differs in result of other tests.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean|number}\n         * Result value of the process.\n         */\n        function XOR(args, table) {\n            for (let i = 0, iEnd = args.length, lastValue, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                switch (typeof value) {\n                    case 'boolean':\n                    case 'number':\n                        if (typeof lastValue === 'undefined') {\n                            lastValue = !!value;\n                        }\n                        else if (!!value !== lastValue) {\n                            return true;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            switch (typeof value2) {\n                                case 'boolean':\n                                case 'number':\n                                    if (typeof lastValue === 'undefined') {\n                                        lastValue = !!value2;\n                                    }\n                                    else if (!!value2 !== lastValue) {\n                                        return true;\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                }\n            }\n            return false;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('XOR', XOR);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return XOR;\n    });\n    _registerModule(_modules, 'Data/Formula/Formula.js', [_modules['Data/Formula/FormulaParser.js'], _modules['Data/Formula/FormulaProcessor.js'], _modules['Data/Formula/FormulaTypes.js']], function (FormulaParser, FormulaProcessor, FormulaType) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /**\n         * Formula engine to make use of spreadsheet formula strings.\n         * @internal\n         */\n        const Formula = {\n            ...FormulaParser,\n            ...FormulaProcessor,\n            ...FormulaType\n        };\n\n        return Formula;\n    });\n    _registerModule(_modules, 'Data/Modifiers/MathModifier.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Data/Formula/FormulaParser.js'], _modules['Data/Formula/FormulaProcessor.js']], function (DataModifier, FormulaParser, FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Replaces formula strings in a table with calculated values.\n         *\n         * @class\n         * @name Highcharts.DataModifier.types.MathModifier\n         * @augments Highcharts.DataModifier\n         */\n        class MathModifier extends DataModifier {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(options) {\n                super();\n                this.options = {\n                    ...MathModifier.defaultOptions,\n                    ...options\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            modifyTable(table, eventDetail) {\n                const modifier = this;\n                modifier.emit({ type: 'modify', detail: eventDetail, table });\n                const alternativeSeparators = modifier.options.alternativeSeparators, formulaColumns = (modifier.options.formulaColumns ||\n                    table.getColumnNames()), modified = table.modified;\n                for (let i = 0, iEnd = formulaColumns.length, columnName; i < iEnd; ++i) {\n                    columnName = formulaColumns[i];\n                    if (formulaColumns.indexOf(columnName) >= 0) {\n                        modified.setColumn(columnName, modifier.processColumn(table, columnName));\n                    }\n                }\n                const columnFormulas = (modifier.options.columnFormulas || []);\n                for (let i = 0, iEnd = columnFormulas.length, columnFormula, formula; i < iEnd; ++i) {\n                    columnFormula = columnFormulas[i];\n                    formula = FormulaParser.parseFormula(columnFormula.formula, alternativeSeparators);\n                    modified.setColumn(columnFormula.column, modifier.processColumnFormula(formula, table, columnFormula.rowStart, columnFormula.rowEnd));\n                }\n                modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n                return table;\n            }\n            /**\n             * Process a column by replacing formula strings with calculated values.\n             *\n             * @private\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to extract column from and use as reference.\n             *\n             * @param {string} columnName\n             * Name of column to process.\n             *\n             * @param {number} rowIndex\n             * Row index to start the replacing process from.\n             *\n             * @return {Highcharts.DataTableColumn}\n             * Returns the processed table column.\n             */\n            processColumn(table, columnName, rowIndex = 0) {\n                const alternativeSeparators = this.options.alternativeSeparators, column = (table.getColumn(columnName, true) || [])\n                    .slice(rowIndex > 0 ? rowIndex : 0);\n                for (let i = 0, iEnd = column.length, cacheFormula = [], cacheString = '', cell; i < iEnd; ++i) {\n                    cell = column[i];\n                    if (typeof cell === 'string' &&\n                        cell[0] === '=') {\n                        try {\n                            // Use cache while formula string is repetitive\n                            cacheFormula = (cacheString === cell ?\n                                cacheFormula :\n                                FormulaParser.parseFormula(cell.substring(1), alternativeSeparators));\n                            // Process parsed formula string\n                            column[i] =\n                                FormulaProcessor.processFormula(cacheFormula, table);\n                        }\n                        catch {\n                            column[i] = NaN;\n                        }\n                    }\n                }\n                return column;\n            }\n            /**\n             * Process a column by replacing cell values with calculated values from a\n             * given formula.\n             *\n             * @private\n             *\n             * @param {Highcharts.Formula} formula\n             * Formula to use for processing.\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to extract column from and use as reference.\n             *\n             * @param {number} rowStart\n             * Row index to start the replacing process from.\n             *\n             * @param {number} rowEnd\n             * Row index to end the replacing process.\n             *\n             * @return {Highcharts.DataTableColumn}\n             * Returns the processed table column.\n             */\n            processColumnFormula(formula, table, rowStart = 0, rowEnd = table.getRowCount()) {\n                rowStart = rowStart >= 0 ? rowStart : 0;\n                rowEnd = rowEnd >= 0 ? rowEnd : table.getRowCount() + rowEnd;\n                const column = [], modified = table.modified;\n                for (let i = 0, iEnd = (rowEnd - rowStart); i < iEnd; ++i) {\n                    try {\n                        column[i] = FormulaProcessor.processFormula(formula, modified);\n                    }\n                    catch {\n                        column[i] = NaN;\n                    }\n                    finally {\n                        formula = FormulaProcessor.translateReferences(formula, 0, 1);\n                    }\n                }\n                return column;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options of MathModifier.\n         * @private\n         */\n        MathModifier.defaultOptions = {\n            type: 'Math',\n            alternativeSeparators: false\n        };\n        DataModifier.registerType('Math', MathModifier);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MathModifier;\n    });\n    _registerModule(_modules, 'masters/modules/math-modifier.src.js', [_modules['Dashboards/Globals.js'], _modules['Data/Formula/Formula.js']], function (Globals, Formula) {\n\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        // Fill registries\n        /* *\n         *\n         *  Namespace\n         *\n         * */\n        const G = Globals;\n        G.Formula = Formula;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return G;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Dashboards","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","booleanRegExp","decimal1RegExp","decimal2RegExp","functionRegExp","operatorRegExp","rangeA1RegExp","rangeR1C1RegExp","referenceA1RegExp","referenceR1C1RegExp","extractParantheses","text","parantheseLevel","i","iEnd","length","char","parantheseStart","substring","error","Error","name","extractString","start","escaping","parseArgument","alternativeSeparators","match","beginColumnRelative","beginRowRelative","endColumnRelative","endRowRelative","range","type","beginColumn","parseInt","beginRow","endColumn","endRow","parseReferenceColumn","formula","parseFormula","decimalRegExp","next","trim","columnRelative","rowRelative","reference","column","row","push","parseFloat","string","parantheses","parseArguments","argumentsSeparator","term","paranteses","position","code","factor","charCodeAt","Math","pow","FormulaProcessor","getArgumentValue","ABS","table","value","abs","values","value2","NaN","registerProcessorFunction","AND","AVERAGEA","count","result","isNaN","j","jEnd","COUNTA","getArgumentsValues","IF","ISNA","MOD","value1","getModeMap","modeMap","MULT","keys","Object","modeKeys","modeCount","key","SNGL","modeKey","keyValue","NOT","OR","XOR","lastValue","FormulaParser","FormulaType","DataModifier","MathModifier","constructor","options","defaultOptions","modifyTable","eventDetail","modifier","emit","formulaColumns","getColumnNames","modified","columnName","indexOf","setColumn","processColumn","columnFormulas","columnFormula","processColumnFormula","rowStart","rowEnd","rowIndex","getColumn","slice","cacheFormula","cell","cacheString","processFormula","getRowCount","translateReferences","registerType","Globals","Formula","G"],"mappings":"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"}